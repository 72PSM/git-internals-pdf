h2. About this book

It took me a pretty long time to really get git. As we've continued to use git more and more in our company, we've found ourselves having to teach people what it is and why we use it over and over again, and the reality is that git generally has a pretty steep learning curve compared to some other systems. I've seen case after case of developers who love git after they finally understand it, but getting to that point is often somewhat painstaking.

This book then is aimed at the developer who does not particularly like SVN or whatever SCM system they are currently using, has heard good things about git, but doesn't know where to start or why it's so wonderful. It is meant to explain git as simply and graphically as possible in a clean, concise, easily readable volume. I would like you to be able to get through this book and understand git at a fundamental level, very quickly.

To accomplish this, I'm starting the book out (after the introduction) with a section about what git does, rather than how to use it. I found that I didn't really understand git and had many problems in using it until I understood what it was doing rather than understanding it as a different, weird SVN-like system.

h2. Installing Git

todo. clean up this whole section, and actually run through each of these (yes, even windows!)

Before we can start playing with git, we'll have to install it. I'll quickly cover installing git on Linux, Mac and Windows.

You can download git from http://git.or.cz/

http://kernel.org/pub/software/scm/git/

h3. Installing on Linux

wget http://kernel.org/pub/software/scm/git/git-1.5.4.4.tar.bz2
tar jxpvf git-1.5.4.4.tar.bz2
cd git-1.5.4.4
make prefix=/usr all doc info
sudo make prefix=/usr install install-doc install-info

or : apt-get git-core, yum install git-core


h3. Installing on Mac

You are likely going to want to install git without the asciidoc dependency because it is a pain to install.  When you compile from source, you will see

h4. Mac 10.4 - Tiger

There are some requirements you'll have to install before you can compile git.

http://sourceforge.net/projects/expat/

However, if you want an easier path, you can use the excellent MacPorts software:

http://www.macports.org/

and just run 

# port install git-core


h4. Mac 10.5 - Leopard

All the requirements are installed with the developer CD, so you can just download source and compile pretty easily if the developer tools are installed. 

MacPorts is also an easy option if you have that installed.


h3. Windows

Cygwin 	http://www.cygwin.com/setup.exe

http://code.google.com/p/msysgit/

A TortoiseCVS lookalike for Git

http://repo.or.cz/w/git-cheetah.git/

h2. A Short History of Git

Git started with Linus Torvalds scratching the very serious itch of needing a fast, efficient and massively distributed source code management system for Linux kernel development. 

The kernel team had moved from a patch emailing system to the proprietary BitKeeper SCM in 2002.  That ended in April 2005 when BitMover stopped providing a free version of it's tool to the open source community because they felt some developers had reverse engineered it in violation of the license.

Since Linus had (and still has) a passionate dislike of all existing source code management systems, he decided to write his own.  Thus, in April of 2005, Git was born.  A few months later, in July, maintenance was turned over to Junio Hamano, who has maintained the project ever since.

note. "I'm an egotistical bastard, and I name all my projects after myself. First Linux, now git." - Linus

Git started out as a collection of lower level functions used in various combinations by perl scripts.  Recently (since 1.0), more and more of the perl scripts have been re-written in C, increasing portability and speed.

todo. growth and adoption - list some projects (kernel, X.Org, Mesa3D, Compiz, Wine, OLPC, Fedora, Samba | ruby: rubinius, merb, god, github, rails?)

http://git.fedoraproject.org/git/

h1. Section 1 - Understanding Git

In this section, we will go over what git was built for and how it works, hopefully laying the groundwork to properly understand what it is doing when we run the commands.

When I learned Git, as many people do, I learned it in the context of other SCMs I had used - Subversion or CVS.  I really think this is a horrible way to learn Git.  I felt far more comfortable with it when I stopped thinking that 'git add' was sort of like 'svn add', but instead understood what it was actually doing.  Then I found I could find new and interesting ways to use what is really a very powerful and cool toolset.

!../artwork/s1/what-git-is.png!

So, let's see what it's doing behind the scenes first. 

h2. What is Git?

Git is a stupid content tracker.  That is probably the best description of it - don't think of it in a 'like SVN, but...' context, but more like a really interesting file system.  

Git tracks content - files and directories.  It is at it's heart a collection of simple tools that implement a tree history storage and directory content management system.  It is simply used as an SCM, not really designed as one.


"In many ways you can just see git as a filesystem â€” it's content-addressable, and it has a notion of versioning, but I really really designed it coming at the problem from the viewpoint of a filesystem person (hey, kernels is what I do), and I actually have absolutely zero interest in creating a traditional SCM system." - Linus (http://marc.info/?l=linux-kernel&m=111314792424707)

  
When most SCMs store a new version of a project, they store the code delta or diff.  When Git stores a new version of a project, it stores a new tree - a bunch of blobs of content and a collection of pointers that can be expanded back out into a full directory of content and subdirectories.  If you want a diff between two versions, it doesn't add up all the deltas, it simply looks at the two full directories and runs a new diff on them.

This is what fundamentally allows the system to be easily distributed - it doesn't have issues figuring out how to apply a complex series of deltas, it simply transfers all the directories that one user has and another does not have but is requesting.  It is efficient about it - it only stores identical files and directories once and it can compress and transfer it's content using delta-compressed packfiles - but in concept, it is a very simple beast.  Git is at it's heart very stupid simple.

h3. Focus and Design

There are a number of areas that the developers of Git, including and especially Linus, have focused on in conceiving and building Git.

h4. Non-linear Development

branching and merging

h4. Distributed Development

local copy of the entire development history, no central repository

h3. Efficiency

seriously faster than nearly all other SCM systems for most operations.  

todo. table of speed benchmarks for git vs. svn vs. ??
      - add, commit, push, diff, merge
      - directory/checkout sizes?

h3. A Toolkit Design

Following the Unix tradition, Git is a collection of many small tools written in C [1]

todo. expand this whole chapter

h2. Git Object Types 

There are four main object types in git, the first three being the most important to really understand the main functions of git.

All of these types of objects are stored in the git object database, which is kept in the git directory [see git directory].  Each object is compressed (with Zlib) and referenced by the SHA1 value of its contents plus a small header.  In the examples, I will use the first 6 characters of the SHA for simplicity, but the actual value is 40 characters long.

To demonstrate these examples, we will develop a small ruby library that provides very simple bindings to git, keeping the project in a git repository.  The basic layout of the project is this:

!../artwork/s1/layout.png!

Let's take a look at what git does when this is committed to a repository.

h3. The Blob

_sidebar of git object sha algorithm (git-object-sidebar.textile)_

In git, the contents of files are stored as *blobs*.

!../artwork/s1/blobs.png!

It is important to note that it is the _contents_ that are stored, not the files.  The names and permissions of the files are not stored with the blob, just the contents.  

!../artwork/s1/blob-expand.png!

This means that if you have two files anywhere in your project that are exactly the same, even if they have different names, git will only store the blob once.  This also means that during repository transfers, such as clones or fetches, git will only transfer the blob once, then expand it out into multiple files upon checkout.

h3. The Tree

_sidebar of tree object encoding algorithm (git-tree-sidebar.textile)_

Directories in git basically correspond to *trees*.  

!../artwork/s1/trees.png!

A tree is a list of trees and blobs that the tree contains, along with the names and permissions of those blobs and trees.  The contents section of a tree object consists of a very simple text file that lists the _mode_, _type_, _name_ and _sha_ of each entry (see the sidebar for details).

!../artwork/s1/tree-expand.png!


h3. The Commit

So, now that we can store arbitrary trees of content in Git, where does the 'history' part of 'tree history storage system' come in?  The answer is the *commit* object.

!../artwork/s1/commit.png!

The commit is very simple, much like the tree.  It simply points to a tree and keeps an _author_, _committer_, _message_ and any _parent_ commits that directly preceded it.  

!../artwork/s1/commit-expand.png!

Since this was my first commit, there are no parents.  If I commit a second time, the commit object will look more like this:

!../artwork/s1/commit-expand2.png!

Notice how the _parent_ in that commit is the same SHA1 value of the last commit we did?  Most times a commit will only have a single parent like that, but if you merge two branches, the next commit will point to both of them.

note. the current record for number of commit parents in the Linux kernel is 12 - _12_ branches merged in a single commit 

h3. The Tag

The final type of object you will find in a git database is the *tag*.  This is an object that provides a permanent shorthand name for a particular commit.  It contains an _object_, _type_, _tag_, _tagger_ and a _message_. Normally the type is a 'commit' and the object is the sha of the commit you're tagging.  The tag can also be GPG signed, providing cryptographic integrity to a release or version.

!../artwork/s1/tag-expand.png!

We'll talk a little bit more about tags and how they differ from _branches_ (which also point to commits, but are not stored as objects) in the section on [the git data model], where we'll pull all of this together into how all these objects relate to each other conceptually.

h2. The Git Directory

When you initialize a git repository, either by cloning an existing one or creating a new one, the first thing git does is create a "Git Directory".  This is the directory that stores all the object data, tags, branches, hooks and more.  Everything that git permanently stores goes in this single directory.  When you clone someone else's repository, it basically just copies the contents of this directory to your computer.  Without a checkout (called a "working directory") this is called a "bare" git repo and moving it to another computer backs up your entire project history.  It is the soul of git.

When you run 'git init' to initialize your repository, the git directory is by default installed in your current working directory as '.git'.  This can be overridden with the _GIT_DIR_ environment variable at any time.  In fact, the git directory does not need to be in your source tree at all.  It's perfectly acceptable to keep all your git directories in a central place (/opt/git/myproject.git) and just make sure to set the GIT_DIR variable when you switch projects you are working on (/home/username/projects/myproject).

The git directory for our little project looks something like this:

code. simple-git-dir-tree.txt

For more in depth information on the git directory layout, see the "git repository layout docs.":http://www.kernel.org/pub/software/scm/git/docs/repository-layout.html

For now, let's go over some of the more important contents of this directory.

h3. .git/config

This is the main git configuration file.  It keeps your project specific git options, such as your remotes, push configurations, tracking branches and more.  Your configuration will be loaded first from this file, then from a ~/.gitconfig file and then from an /etc/gitconfig file, if they exist.

Here is an example of what a config file might look like:

code. config-example.txt
       
See [config section] for more information on available configuration options.

h3. .git/index

This is the default location of the 'index' file for your git project.  This location can be overridden with the _GIT_INDEX_ environment variable, which is sometimes useful for temporary tree operations.  See [the index] or [advanced index operations] sections for more information on the git index.

h3. .git/objects/

This is the main directory that holds the data of your git objects and pack files - that is, all the contents of the files you have ever checked in, plus your commit, tree and tag objects.

The files are stored by their SHA1 values.  The first two characters make up the subdirectory and the last 38 is the filename.  For example, if the SHA for a blob we've checked in was

code. a576fac355dd17e39fd2671b010e36299f713b4d

the file we would find the Zlib compressed contents in is

code. [GIT_DIR]/objects/a5/76fac355dd17e39fd2671b010e36299f713b4d

h3. .git/refs/

This directory normally has three subdirectories in it - _heads_, _remotes_ and _tags_.  Each of these directories will hold files that correspond to your local branches, remote branches and tags, respectively. 

For example, if you create a 'development' branch, the file .git/refs/heads/development will be created and will contain the sha of the commit that is the latest commit of that branch.

h3. .git/HEAD

This file holds a reference to the branch you are currently on.  This basically tells git what to use as the parent of your next commit.  The contents of it will generally look like this:

code. ref: refs/heads/master

h3. .git/hooks

This directory contains shell scripts that are invoked after the git commands they are named after.  For example, after you run a commit, git will try to execute the _post-commit_ script, if it has executable permissions.

See [hooks section] or the 
"online hooks documentation":http://www.kernel.org/pub/software/scm/git/docs/hooks.html
for more information on what you can do with hooks.

h2. The Git Data Model

In computer science speak, the Git object data store is a Directed Acyclic Graph. That is, starting at any commit you can traverse it's parents in one direction and there is no chain that begins and ends with the same object. 

All commit objects point to a tree and optionally to previous commits.  All trees point to one or many blobs and/or trees.  Given this simple model, we can store and retrieve vast histories of complex trees of arbitrarily changing content quickly and efficiently.

This section is meant to demonstrate how that model looks.

h3. References

In addition to the Git objects, which are immutable - that is, they cannot ever be changed, there are references also stored in Git.  Unlike the objects, references can constantly change.  They are simple pointers to a particular commit, something like a tag, but easily moveable.

Examples of references are branches and remotes.  A branch in git is nothing more than a file in the _.git/refs/heads/_ directory that contains the sha of the most recent commit of that branch.  To branch that line of development, all git does is create a new file in that directory that points to the same sha.  Then, as you continue to commit, one of the branches will keep changing to point to the new commit shas, while the other one can stay where it was.

h3. The Model

The basic data model I've been explaining looks something like this:

!../artwork/s1/dag-model.png!

The cheap references I've represented as the grey boxes, the immutable objects are the colored round cornered boxes.

h3. An Example

Lets look at an example of simple usage of git and which objects are stored in the git object store as we go.

To begin with, we commit an initial tree of three files and two subdirectories, each directory with one file in it.  Possibly something like this:

code. model-tree-example.txt

When we first commit this tree, our Git model may look something like this:

!../artwork/s1/object-dag-tree1.png!

We have 3 trees, 3 blobs, 1 commit that points to the top of the tree, the current branch pointing to our last commit and the HEAD file pointing to the branch we're currently on to let Git know which commit will be the parent for the next commit.

Now let's assume that we change the _lib/base/base_include.rb_ file and commit again.  At this point, a new blob is added, which changes the tree that points to it, which changes the tree that points to that tree and so on to the top of the entire directory.  Then a new commit object is added which points to it's parent and the new tree and the branch reference is moved forward.

Let's also say at this point we tag this commit as a release, which adds a new tag object.  At this point, we'll have the following in Git.

!../artwork/s1/object-dag-tree2.png!

Notice how the other two blobs that were not changed were not added again.  The new trees that were added point to the same blobs in the data store that the previous trees pointed to.

Now let's say we modify the _init.rb_ file at the base of the project.  The new blob will have to be added, which will add a new top tree, but all the subtrees will not be modified, so Git will re-use those references.  Again, the branch reference will move forward and the new commit will point to it's parent.

!../artwork/s1/object-dag-tree3.png!

At this point, let's stop to look at the objects we now have in our repository.  From this, we can easily recreate any of the three directories we committed by following the graph from the commit object.

For instance, if we wanted the first tree, we could look for the parent of the parent of the HEAD, or the parent of the tag.  If we wanted the second tree, we could ask for the commit pointed to by the tag, and so on.

!../artwork/s1/object-dag.png!

So, to keep all the information and history on the three versions of this tree, git stores 16 immutable, signed, compressed objects.

h3. Branching and Merging

Now, let's see how git handles branching, fetching and merging operations, data-wise.

For the following illustrations, we will represent the entire tree and the commit it points to as a single object. 

!../artwork/s1/branches1.png!

h4. Simple Case

Let's say we work on a project for a while, then we get an idea for something that may not work out, but we want to do a quick proof-of-concept.  We create a new branch called 'experiment' off of our main branch, which is by convention called 'master'.  We then switch to the new branch, then create a few commits.

!../artwork/s1/branch-story1.png!

Then, our boss comes in and says we need a hot fix to production.  So we switch back to our master branch, make the change, push the release and then tag the commit with the release number. Then we go back to our 'experiment' branch, continue working and commit again.

!../artwork/s1/branch-story2.png!

At this point, we show the new branch to our co-workers and everyone likes the new changes. We decide we want to merge them back into our main branch, so we merge the changes and delete our 'experiment' branch.

!../artwork/s1/branch-story3.png!

h4. Remotes

Now lets take a look at remotes.  Remotes are basically other peoples branches of the same repository.  If you got your repository by cloning it, rather than initializing it, you should have a remote branch of where you copied it from automatically added as 'origin' by default.  Which means the tree that was checked out during your initial clone would be referenced as 'origin/master', which means 'the master branch of the origin remote'. 

Lets say you clone someone's repository and make a few changes.  You would have two references, one to 'origin/master' which points to where the master branch was on the persons repository you cloned from when you did so, and a 'master' branch that points the most recent local commit.

!../artwork/s1/remote-story1.png!

Now lets say you run a _fetch_. A fetch pulls all the refs and objects that you don't already have from the remote repository you specify.  By default, it is origin, but you can name your remotes anything, and you can have more than one.  Lets say we fetch from the repository that we originally cloned from and they had been doing some work.  They have now committed a few times on their master branch, but they also branched off at one point to try an idea, and they named the branch 'idea' locally.  We now have access to those changes as 'origin/idea'.

!../artwork/s1/remote-story2.png!

We look at the 'idea' branch and like where they're going with it, but we also want the changes they've made on their master branch, so we do a 3-way merge of their two branches and our master.  We don't know how well this is going to work, so we make a 'tryidea' branch first and then do the merge there.

!../artwork/s1/remote-story3.png!

Now we can run our tests and merge back into our master branch if we want.  Then we can tell our friend we cloned from to fetch from our repository, where we've merged their two branches for them and integrated some of our changes as well.  They can choose to accept or reject that "patch".

h4. Rebasing


h2. The Treeish


* full sha - dae86e1950b1277e545cee180551750029cfe735
* partial sha - dae86e
* branch/tag name - master
* date spec - master@{yesterday}
** the value of master yesterday
* ordinal spec - master@{5}
** 5th prior value of master
* carrot parent - e65s46^^2
** second parent of commit
* tilde spec - e65s46~5 (e65s46^^^^^^^^^^)
** 5th generation grandparent of commit
* tree pointer - e65s46^^{tree}
** blob spec - master:/path/to/file

$ git log --walk-reflogs master # show reflog entries for master

h2. Working Directory

The working directory is the checkout of the current branch you are working on.  What is really important to note here is that this code is a working copy - it is not really important.

This is something that developers from the Subversion world have a hard time understanding and tends to scare them mightily.  If you check out a different branch, git will basically make your working directory look like that branch, removing any checked in content that is currently in your working directory that is not in the new tree.

Most long time Subversion users don't like to see content automatically removed from their directories, but that's one of the shifts you'll need to make.  Your working directory is temporary - everything is stored permanently in your git repository.  Your working directory is just a copy of a tree so you can edit it and commit changes. 

h2. The Index    

The index was called the cache for a while, because that's largely what it does.  It is a staging area for changes that are made to files or trees that are not committed to your repository yet.  It is also used to speed up some operations.  It acts as sort of a middle ground between your working directory and your repository.

* keeping track of the state of working directory files
* staging changes
* generating commits

h1. Section 2 - Using Git

Now that you understand what Git does at a fundamental level - how it tracks and stores content, how it stores branches and merges and tracks remote copies of the repository, let's see how to actually use it.

h2. The SCM (the porcelain)

history of toolkit design and reluctance of full SCM
Cogito and it's death

h2. Getting a Git Repository

git clone

h2. Normal Workflow Examples

h3. Initializing

init, .gitignore

h3. Adding and Committing

add, commit (-a -v -m)

h3. Status

status, ls-files

showing the index and working tree

h2. Log - the Commit History

h2. Browsing Git

show, ls-tree, cat-file -p

h2. Git Diff

diff - getting and sending patchfiles

h2. Branching

branch, checkout
reset
git branch recovered-branch 7281251ddd


h2. Simple Merging

h2. Rebasing

h2. Distributed Workflow Examples

h3. Cloning

h3. Fetching, Pulling (tracking branches)

h3. Pushing

h3. Formatting Patches


h2. All About Remotes (refspec)

h2. Tagging

h2. Sharing Repositories

h3. Over SSH

git clone --bare; scp

h3. Over Git

git daemon --detach

h3. Over Http

git update-server-info

h4. GitHub

h1. Section 3 - Git and Other Systems

h2. Git and SVN 

h3. Pros and Cons 

h3. Importing existing SVN projects 

h3. git-svn

h3. git-svn-server

h3. Piston / SVN Externals 

h2. Git and Ruby 

h3. Ruby/Git

h3. Grit

h3. Git-Ruby

h2. Git and Application Deployment 

h3. Capistrano Module

h3. Vlad the Deployer Module

h1. Advanced Git

h2. Bisect

h2. Reading and Writing Trees

h2. Advanced Index Operations

h2. File and Index Staging

h2. Submodules

h2. Advanced Merging

* merge strategies
** resolve
** recursive
** octopus

h2. Shared Repositories

h2. Hooks

h2. Configuration Options

h2. History Manipulation

h2. Repository Maintenance

h2. Patch Management

h2. Recovering From Corruption

h1. Commands Overview

h2. The Plumbing

h2. The Porcelain

h1. References and Endnotes

Here are some references that I used or that you may use to find out more about Git.


h2. Web Documentation

"Main Git Documentation":http://www.kernel.org/pub/software/scm/git/docs/
- fantastic reference for all the command line programs

"Git for Computer Scientists":http://eagain.net/articles/git-for-computer-scientists/
- good detail about the DAG object model

"Junio Hamano New Git Maintainer":http://kerneltrap.org/node/5496
- some history on git and Junio becoming the new maintainer


h2. Screencasts

"Git Peepcode Screencast":http://peepcode.com/products/git

"RailsCasts Git Screencast":http://railscasts.com/episodes/96

"Using Git to Manage and Deploy Rails Apps":http://www.jointheconversation.org/railsgit

