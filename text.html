<h2>About this book</h2>


	<p>It took me a pretty long time to really get Git. As I&#8217;ve continued to use Git more and more where I work, I&#8217;ve found myself trying to teach people what it is and why we use it over and over again, and the reality is that Git generally has a pretty steep learning curve compared to many other systems. I&#8217;ve seen case after case of developers who love Git after they finally understand it, but getting to that point is often somewhat painstaking.</p>


	<p>This book is aimed at the developer who does not particularly like Subversion, Perforce or whatever <span class="caps">SCM</span> system they are currently using, has heard good things about Git, but doesn&#8217;t know where to start or why it&#8217;s so wonderful. It is meant to explain Git as simply as possible in a clean, concise, easily readable volume. My goal is to help you understand Git internals as well as usage at a fundamental level by the time you finish this book.</p>


	<p>To accomplish this, I&#8217;m starting the book out (after the introduction) with a section about what Git actually <strong>does</strong>, rather than how to use it. I found that I didn&#8217;t really understand Git and had many problems using it until I understood what it was actually doing at a low level, rather than thinking of it as a different, weird <span class="caps">SVN</span>-like system.</p>


	<h2>Installing Git</h2>


	<p>Before we can start playing with Git, we&#8217;ll have to install it. I&#8217;ll quickly cover installing Git on Linux, Mac and Windows.  I will not get into really fine detail, because others have done that much better, but I will give you an overview and links as to where to find more detailed instructions on each platform.</p>


	<p>For any of these examples, you can find a link to the most current Git source code at <a href="http://git.or.cz/">git.or.cz</a>.</p>


	<p>I would recommend compiling from source if possible, simply because Git is lately making big strides in usability, so more current versions may be a bit easier to use.</p>


	<h3>Installing on Linux</h3>


	<p>If you are installing from source, it will go something like the standard:</p>


	<p>shell. $ wget http://kernel.org/pub/software/scm/git/git-1.5.4.4.tar.bz2
$ tar jxpvf git-1.5.4.4.tar.bz2
$ cd git-1.5.4.4
$ make prefix=/usr all doc info
$ sudo make prefix=/usr install install-doc install-info</p>


	<p>If you are running Ubuntu or another Debian based system, you can run</p>


	<p>shell. $ apt-get git-core</p>


	<p>or on yum based systems, you can often run:</p>


	<p>shell. $ yum install git-core</p>


	<h3>Installing on Mac</h3>


	<p>You are likely going to want to install Git without the asciidoc dependency because it is a pain to install.   Other than that, what you basically need is Curl and Expat.  With the exception of the Leopard binary <span class="caps">OS X</span> installer, you will also need the Developer Tools installed.  If you don&#8217;t have the <span class="caps">OS X</span> install discs anymore, you can get the tools from the 
<a href="http://developer.apple.com/tools/">Apple Website</a></p>


	<h4>Mac 10.4 &#8211; Tiger</h4>


	<p>There are some requirements you&#8217;ll have to install before you can compile Git.  Expat can be installed roughly like this:</p>


	<p>shell. curl -O http://surfnet.dl.sourceforge.net/sourceforge/expat/expat-2.0.1.tar.gz
tar zxvf expat-2.0.1.tar.gz 
cd expat-2.0.1
./configure&#8212;prefix=/usr/local
make
make check
sudo make install
cd ..</p>


	<p>Then download and compile Git as per the Linux instructions.</p>


	<p>However, if you want an easier path, you can use the excellent MacPorts software.  To install MacPorts, simply follow the instructions on the 
<a href="http://www.macports.org/">MacPorts Homepage</a>, and then just run :</p>


	<p>shell. $ sudo port install git-core</p>


	<p>For an in depth tutorial on installing on 10.4, see 
<a href="http://blog.kineticweb.com/articles/2007/08/26/compiling-git-for-mac-os-x-10-4-10-intel">this article</a></p>


	<h4>Mac 10.5 &#8211; Leopard</h4>


	<p>The easiest way to install is most likely the 
<a href="http://code.google.com/p/git-osx-installer/">Git <span class="caps">OSX</span> Installer</a>, which you can get from Google Code, and has just recently been linked to as the &#8220;official&#8221; Mac version on the Git homepage.  Just download and run the dmg from the website.</p>


	<p>If you want to compile from source, all the requirements are installed with the developer CD, so you can just download source and compile pretty easily if the developer tools are installed.</p>


	<p>Finally, MacPorts is also an easy option if you have that installed.</p>


	<p>For an in-depth tutorial on installations under Leopard, see 
<a href="http://blog.kineticweb.com/articles/2007/10/30/compiling-git-for-mac-os-x-leopard-10-5">this article</a></p>


	<h3>Windows</h3>


	<p>There are two options on Windows currently, but the popular one is 
<a href="http://code.google.com/p/msysgit/">MSysGit</a>
, which installs easily and is runnable on the Windows command line.  Simply download the exe file from the 
<a href="http://code.google.com/p/msysgit/downloads/list">downloads list</a>
, execute it and follow the on-screen instructions.</p>


	<h2>A Short History of Git</h2>


	<p>The Git project started with Linus Torvalds scratching the very serious itch of needing a fast, efficient and massively distributed source code management system for Linux kernel development.</p>


	<p>The kernel team had moved from a patch emailing system to the proprietary BitKeeper <span class="caps">SCM</span> in 2002.  That ended in April 2005 when BitMover stopped providing a free version of its tool to the open source community because they felt some developers had reverse engineered it in violation of the license.</p>


	<p>Since Linus had (and still has) a passionate dislike of just about all existing source code management systems, he decided to write his own.  Thus, in April of 2005, Git was born.  A few months later, in July, maintenance was turned over to Junio Hamano, who has maintained the project ever since.</p>


	<p>note. &#8220;I&#8217;m an egotistical bastard, and I name all my projects after myself. First Linux, now git.&#8221; &#8211; Linus</p>


	<p>Git started out as a collection of lower level functions used in various combinations by shell and perl scripts.  Recently (since 1.0), more and more of the scripts have been re-written in C (referred to as built-ins), increasing portability and speed.</p>


	<p>Though originally used for just the Linux kernel, the Git project spread rapidly, and quickly became used to manage a number of other Linux projects, such as the X.org, Mesa3D, Wine, Fedora and Samba projects.  Recently it has begun to spread outside the Linux world to manage projects such as Rubinius, Merb, Ruby on Rails, Nu, Io and many more major open source projects.</p>


	<h1>Section One &#8211; Understanding Git</h1>


	<p>In this section, we will go over what Git was built for and how it works, hopefully laying the groundwork to properly understand what it is doing when we run the commands.</p>


	<p>note.  the first commit message for the Git project was &#8216;initial version of &#8220;git&#8221;, the information manager from hell&#8217; &#8211; Linus, 4/7/05</p>


	<p>When I learned Git, as many people do, I learned it in the context of other SCMs I had used &#8211; Subversion or <span class="caps">CVS</span>.  I have come to believe that this is a horrible way to learn Git.  I felt far more comfortable with it when I stopped thinking that &#8216;git add&#8217; was sort of like &#8216;svn add&#8217;, but instead understood what it was actually doing.  Then I found I could find new and interesting ways to use what is really a very powerful and cool toolset.</p>


	<p><img src="vector/what-git-is.eps" alt="" /></p>


	<p>So, let&#8217;s see what it&#8217;s doing behind the scenes first.</p>


	<h2>What is Git?</h2>


	<p>Git is a stupid content tracker.  That is probably the best description of it &#8211; don&#8217;t think of it in a &#8216;like (insert favorite <span class="caps">SCM</span> system), but&#8230;&#8217; context, but more like a really interesting file system.</p>


	<p>Git tracks content &#8211; files and directories.  It is at its heart a collection of simple tools that implement a tree history storage and directory content management system.  It is simply used as an <span class="caps">SCM</span>, not really designed as one.</p>


	<p>note. &#8220;In many ways you can just see git as a filesystem â€” it&#8217;s content-addressable, and it has a notion of versioning, but I really really designed it coming at the problem from the viewpoint of a filesystem person (hey, kernels is what I do), and I actually have absolutely zero interest in creating a traditional <span class="caps">SCM</span> system.&#8221; &#8211; <a href="http://marc.info/?l=linux-kernel&#38;m=111314792424707">Linus</a></p>


	<p>When most SCMs store a new version of a project, they store the code delta or diff.  When Git stores a new version of a project, it stores a new <em>tree</em> &#8211; a bunch of blobs of content and a collection of pointers that can be expanded back out into a full directory of files and subdirectories.  If you want a diff between two versions, it doesn&#8217;t add up all the deltas, it simply looks at the two trees and runs a new diff on them.</p>


	<p>This is what fundamentally allows the system to be easily distributed &#8211; it doesn&#8217;t have issues figuring out how to apply a complex series of deltas, it simply transfers all the directories and content that one user has and another does not have but is requesting.  It is efficient about it &#8211; it only stores identical files and directories once and it can compress and transfer its content using delta-compressed packfiles &#8211; but in concept, it is a very simple beast.  Git is at it&#8217;s heart very stupid-simple.</p>


	<h3>Focus and Design</h3>


	<p>There are a number of areas that the developers of Git, including and especially Linus, have focused on in conceiving and building Git.  There may be a lot of things that Git is not good at, but these things are what Git is <em>very</em> good at.</p>


	<h4>Non-Linear Development</h4>


	<p>Git is optimized for cheap and efficient branching and merging.  It is built to be worked on simultaneously by many people, having multiple branches developed by individual developers, being merged, branched and re-merged constantly.  Because of this, branching is incredibly cheap and merging is incredibly easy.</p>


	<h4>Distributed Development</h4>


	<p>Git is built to make distributed development simple.  No repository is special or central in Git &#8211; each clone is basically equal and could generally replace any other one at any time.  It works completely offline or with hundreds of remote repositories that can push to and/or fetch from each other over several simple and standard protocols.</p>


	<h3>Efficiency</h3>


	<p>Git is very efficient.  Compared to many popular <span class="caps">SCM</span> systems, it seems downright unbelievably fast.  Most operations are local, which reduces unnecessary network overhead. Repositories are generally packed very efficiently, which often leads to surprisingly small repo sizes.</p>


	<p>note.  The Ruby on Rails Git repository download, which includes the full history of the project &#8211; every version of every file, weighs in at around 13M, which is not even twice the size of a single checkout of the project (<sub>9M).  The Subversion server repository for the same project is about 115M.</p>


	<p>Git also is efficient in its network operations &#8211; the common Git transfer protocols transfer only packed versions of only the objects that have changed.  It also won&#8217;t try to transfer content twice, so if you have the same file under two different names, it will only transfer the content once.</p>


	<h3>A Toolkit Design</h3>


	<p>Git is not really a single binary, but a collection of dozens of small specialized programs, which is sometimes annoying to people trying to learn Git, but is pretty cool when you want to do anything non-standard with it.  Git is less a program and more a toolkit that can be combined and chained to do new and interesting things.</p>


	<p>note. For a long time, Git was just the raw toolkit and the project to wrap those into a user friendly <span class="caps">SCM</span> was called &#8216;Cogito&#8217;.  That project has since been abandoned as Git itself became easier to use.</p>


	<p>The tools can be more or less divided into two major camps, often referred to as the &#8216;porcelain&#8217; and the &#8216;plumbing&#8217;.  The &#8216;plumbing&#8217; is not really meant to be used by people on the command line, but rather to do simple things flexibly and are combined by programs and scripts into &#8216;porcelain&#8217; programs.  The &#8216;porcelain&#8217; programs are largely what we will be focusing on in this book &#8211; the user-oriented interfaces to do <span class="caps">SCM</span> type things, hiding the low-level fun.</p>


	<h2>Git Object Types</h2>


	<p>Git <em>objects</em> are the actual data of Git, the main thing that the repository is made up of.  There are four main object types in Git, the first three being the most important to really understand the main functions of Git.</p>


	<p>All of these types of objects are stored in the Git <strong>Object Database</strong>, which is kept in the <strong>Git Directory</strong>.  Each object is compressed (with Zlib) and referenced by the <span class="caps">SHA1</span> value of its contents plus a small header.  In the examples, I will use the first 6 characters of the <span class="caps">SHA1</span> for simplicity, but the actual value is 40 characters long.</p>


	<p>To demonstrate these examples, we will develop a small ruby library that provides very simple bindings to Git, keeping the project in a Git repository.  The basic layout of the project is this:</p>


	<p><img src="vector/Layout.eps" alt="" /></p>


	<p>Let&#8217;s take a look at what Git does when this is committed to a repository.</p>


	<h3>The Blob</h3>


	<p>In Git, the contents of files are stored as <strong>blobs</strong>.</p>


	<p><img src="vector/Blobs.eps" alt="" /></p>


	<p>It is important to note that it is the <em>contents</em> that are stored, not the files.  The names and permissions of the files are not stored with the blob, just the contents.</p>


	<p><img src="vector/Blob_Expand.eps" alt="" /></p>


	<p>This means that if you have two files anywhere in your project that are exactly the same, even if they have different names, Git will only store the blob once.  This also means that during repository transfers, such as clones or fetches, Git will only transfer the blob once, then expand it out into multiple files upon checkout.</p>


	<h3>The Tree</h3>


	<p>Directories in Git basically correspond to <strong>trees</strong>.</p>


	<p><img src="vector/Trees.eps" alt="" /></p>


	<p>A tree is a simple list of trees and blobs that the tree contains, along with the names and permissions of those trees and blobs.  The contents section of a tree object consists of a very simple text file that lists the <em>mode</em>, <em>type</em>, <em>name</em> and <em>sha</em> of each entry.</p>


	<p><img src="vector/Tree_Expand.eps" alt="" /></p>


	<h3>The Commit</h3>


	<p>So, now that we can store arbitrary trees of content in Git, where does the &#8216;history&#8217; part of &#8216;tree history storage system&#8217; come in?  The answer is the <strong>commit</strong> object.</p>


	<p><img src="vector/Commit.eps" alt="" /></p>


	<p>The commit is very simple, much like the tree.  It simply points to a tree and keeps an <em>author</em>, <em>committer</em>, <em>message</em> and any <em>parent</em> commits that directly preceded it.</p>


	<p><img src="vector/Commit_Expand.eps" alt="" /></p>


	<p>Since this was my first commit, there are no parents.  If I commit a second time, the commit object will look more like this:</p>


	<p><img src="vector/Commit_Expand2.eps" alt="" /></p>


	<p>Notice how the <em>parent</em> in that commit is the same <span class="caps">SHA1</span> value of the last commit we did?  Most times a commit will only have a single parent like that, but if you merge two branches, the next commit will point to both of them.</p>


	<p>note. The current record for number of commit parents in the Linux kernel is 12 branches merged in a single commit!</p>


	<h3>The Tag</h3>


	<p>The final type of object you will find in a Git database is the <strong>tag</strong>.  This is an object that provides a permanent shorthand name for a particular commit.  It contains an <em>object</em>, <em>type</em>, <em>tag</em>, <em>tagger</em> and a <em>message</em>. Normally the <em>type</em> is a &#8216;commit&#8217; and the <em>object</em> is the <span class="caps">SHA1</span> of the commit you&#8217;re tagging.  The tag can also be <span class="caps">GPG</span> signed, providing cryptographic integrity to a release or version.</p>


	<p><img src="vector/Tag_Expand.eps" alt="" /></p>


	<p>We&#8217;ll talk a little bit more about tags and how they differ from <em>branches</em> (which also point to commits, but are not stored as objects) in the next section, where we&#8217;ll pull all of this together into how all these objects relate to each other conceptually.</p>


	<h2>The Git Data Model</h2>


	<p>In computer science speak, the Git object data is a Directed Acyclic Graph. That is, starting at any commit you can traverse its parents in one direction and there is no chain that begins and ends with the same object.</p>


	<p>All commit objects point to a tree and optionally to previous commits.  All trees point to one or many blobs and/or trees.  Given this simple model, we can store and retrieve vast histories of complex trees of arbitrarily changing content quickly and efficiently.</p>


	<p>This section is meant to demonstrate how that model looks.</p>


	<h3>References</h3>


	<p>In addition to the Git objects, which are immutable &#8211; that is, they cannot ever be changed, there are references also stored in Git.  Unlike the objects, references can constantly change.  They are simple pointers to a particular commit, something like a tag, but easily moveable.</p>


	<p>Examples of references are branches and remotes.  A branch in Git is nothing more than a file in the <em>.git/refs/heads/</em> directory that contains the SHAof the most recent commit of that branch.  To branch that line of development, all Git does is create a new file in that directory that points to the same sha.  Then, as you continue to commit, one of the branches will keep changing to point to the new commit shas, while the other one can stay where it was. <em>(Don&#8217;t worry, we&#8217;ll go over this again a bit later&#8230;)</em></p>


	<h3>The Model</h3>


	<p>The basic data model I&#8217;ve been explaining looks something like this:</p>


	<p><img src="vector/DAG_Model.eps" alt="" /></p>


	<p>The cheap references I&#8217;ve represented as the grey boxes, the immutable objects are the colored round cornered boxes.</p>


	<h3>An Example</h3>


	<p>Lets look at an example of simple usage of Git and which objects are stored in the Git object database as we go.</p>


	<p>To begin with, we commit an initial tree of three files and two subdirectories, each directory with one file in it.  Possibly something like this:</p>


	<p>code. model-tree-example.txt</p>


	<p>When we first commit this tree, our Git model may look something like this:</p>


	<p><img src="vector/Object_DAG_Tree1.eps" alt="" /></p>


	<p>We have 3 trees, 3 blobs, 1 commit that points to the top of the tree, the current branch pointing to our last commit and the <span class="caps">HEAD</span> file pointing to the branch we&#8217;re currently on to let Git know which commit will be the parent for the next commit.</p>


	<p>Now let&#8217;s assume that we change the <em>lib/base/base_include.rb</em> file and commit again.  At this point, a new blob is added, which changes the tree that points to it, which changes the tree that points to that tree and so on to the top of the entire directory.  Then a new commit object is added which points to its parent and the new tree, then the branch reference is moved forward.</p>


	<p>Let&#8217;s also say at this point we tag this commit as a release, which adds a new tag object.  At this point, we&#8217;ll have the following in Git:</p>


	<p><img src="vector/Object_DAG_Tree2.eps" alt="" /></p>


	<p>Notice how the other two blobs that were not changed were not added again.  The new trees that were added point to the same blobs in the data store that the previous trees pointed to.</p>


	<p>Now let&#8217;s say we modify the <em>init.rb</em> file at the base of the project.  The new blob will have to be added, which will add a new top tree, but all the subtrees will not be modified, so Git will re-use those references.  Again, the branch reference will move forward and the new commit will point to its parent.</p>


	<p><img src="vector/Object_DAG_Tree3.eps" alt="" /></p>


	<p>At this point, let&#8217;s stop to look at the objects we now have in our repository.  From this, we can easily recreate any of the three directories we committed by following the graph from the most recent commit object, and having Git expand the trees that are pointed to.</p>


	<p>For instance, if we wanted the first tree, we could look for the parent of the parent of the <span class="caps">HEAD</span>, or the parent of the tag.  If we wanted the second tree, we could ask for the commit pointed to by the tag, and so on.</p>


	<p><img src="vector/Object_DAG.eps" alt="" /></p>


	<p>So, to keep all the information and history on the three versions of this tree, Git stores 16 immutable, signed, compressed objects.</p>


	<h3>Traversal</h3>


	<p>So, what do all the arrows in these illustrations really mean?  How does Git actually retrieve these objects in practice?  Well, it gets the initial <span class="caps">SHA</span> of the starting commit object by looking in the <em>.git/refs</em> directory for the branch, tag or remote you specify.  Then it traverses the objects by walking the trees one by one, checking out the blobs under the names listed.</p>


	<p><img src="vector/Traversing_Git_Objects.eps" alt="" /></p>


	<h2>Branching and Merging</h2>


	<p>Here we come to one of the real strengths of Git, cheap inline branching.  This is a feature that truly sets it apart and will likely change the way you think about developing code once you get used to it.</p>


	<p>When you are working on code in Git, storing trees in any state and keeping pointers to them is very simple, as we&#8217;ve seen.  In fact, in Git the act of creating a new branch is simply writing a file in the &#8217;.git/refs/heads&#8217; directory that has the SHAof the last commit for that branch.</p>


	<p>note.  Creating a branch is nothing more than just writing 40 characters to a file</p>


	<p>Switching to that branch simply means having Git make your working directory look like the tree that SHApoints to and updating the <span class="caps">HEAD</span> file so each commit from that point on moves that branch pointer forward (in other words, it changes the 40 characters in &#8217;.git/refs/heads/[current_branch_name]&#8217; be the <span class="caps">SHA</span> of your last commit).</p>


	<p>Merging is also easy, compared to most <span class="caps">SCM</span> systems &#8211; is simply merging the trees that the commits you are telling it to merge are pointing to, which is much simpler than resolving a bunch of deltas.</p>


	<p>Now, let&#8217;s see how Git handles branching, fetching and merging operations abstractly. For the following illustrations, we will represent the entire tree and the commit it points to as a single object.</p>


	<p><img src="vector/Branches1.eps" alt="" /></p>


	<h3>Simple Case</h3>


	<p>Let&#8217;s say we work on a project for a while, then we get an idea for something that may not work out, but we want to do a quick proof-of-concept.  We create a new branch called &#8216;experiment&#8217; off of our main branch, which is by convention called &#8216;master&#8217;.  We then switch to the new branch and create a few commits.</p>


	<p><img src="vector/Branch_Story1.eps" alt="" /></p>


	<p>Then, our boss comes in and says we need a hot fix to production.  So we switch back to our &#8216;master&#8217; branch, make the change, push the release and then tag the new commit with the release number. Then we go back to our &#8216;experiment&#8217; branch, continue working and commit again.</p>


	<p><img src="vector/Branch_Story2.eps" alt="" /></p>


	<p>At this point, we show the new branch code to our co-workers and everyone likes the new changes. We decide we want to merge them back into our main branch, so we merge the changes and delete our &#8216;experiment&#8217; branch.  Our history of commit objects now looks like this:</p>


	<p><img src="vector/Branch_Story3.eps" alt="" /></p>


	<h3>Remotes</h3>


	<p>Now lets take a look at remotes.  Remotes are basically pointers to branches in other peoples copies of the same repository, often on other computers.  If you got your repository by cloning it, rather than initializing it, you should have a remote branch of where you copied it from automatically added as &#8216;origin&#8217; by default.  Which means the tree that was checked out during your initial clone would be referenced as &#8216;origin/master&#8217;, which means &#8216;the master branch of the origin remote&#8217;.</p>


	<p>Lets say you clone someone&#8217;s repository and make a few changes.  You would have two references, one to &#8216;origin/master&#8217; which points to where the master branch was on the persons repository you cloned from when you did so, and a &#8216;master&#8217; branch that points the most recent local commit.</p>


	<p><img src="vector/Remote_Story1.eps" alt="" /></p>


	<p>Now lets say you run a <em>fetch</em>. A fetch pulls all the refs and objects that you don&#8217;t already have from the remote repository you specify.  By default, it is origin, but you can name your remotes anything, and you can have more than one.  Let&#8217;s say we fetch from the repository that we originally cloned from and they had been doing some work.  They have now committed a few times on their master branch, but they also branched off at one point to try an idea, and they named the branch &#8216;idea&#8217; locally.  We now have access to those changes as &#8216;origin/idea&#8217;.</p>


	<p><img src="vector/Remote_Story2.eps" alt="" /></p>


	<p>We look at the &#8216;idea&#8217; branch and like where they&#8217;re going with it, but we also want the changes they&#8217;ve made on their &#8216;master&#8217; branch, so we do a 3-way merge of their two branches and our master.  We don&#8217;t know how well this is going to work, so we make a &#8216;tryidea&#8217; branch first and then do the merge there.</p>


	<p><img src="vector/Remote_Story3.eps" alt="" /></p>


	<p>Now we can run our tests and merge everything back into our &#8216;master&#8217; branch if we want.  Then we can tell our friend we cloned from to fetch from our repository, where we&#8217;ve merged their two branches for them and integrated some of our changes as well.  They can choose to accept or reject that &#8220;patch&#8221;.</p>


	<h3>Rebasing</h3>


	<p>Let&#8217;s say you and another developer, Jen, are working on the same project simultaneously.  She clones from you, and works for a while and commits.  You have committed in the meantime and want to get your work in sync, so you add her repository as the remote &#8216;jen&#8217;, do a fetch and merge her changes in, creating a new merge commit.  (All commits that are simply merges are given a darker color in this example)</p>


	<p><img src="vector/Rebase1.eps" alt="" /></p>


	<p>At this point, you both do work and commit changes and then you fetch and merge from her again.  Then she does another commit and you fetch and merge once more.  At this point, you&#8217;ll have a commit history that looks something like this:</p>


	<p><img src="vector/Rebase2.eps" alt="" /></p>


	<p>Perfectly fine, but it can get a little confusing when you litter the history with all those commits that do nothing but merge unshared changes.  The longer you keep out of sync, the worse this can get.</p>


	<p>This is where the rebasing command comes in.  With rebase, Git will checkout the <em>upstream branch</em>, in this case, Jen&#8217;s master branch, and then replay all the changes you&#8217;ve done since you forked on top of those files, as if you had forked your work off at <em>that</em> point and done all your changes, rather than earlier.</p>


	<p>Rebase will literally produce a series of patch files of your work and start applying them to the upstream branch, automatically making new commits with the same messages as before and orphaning your older ones.  These objects can then be removed, since nothing points to them, when you run the garbage collection tools (see &#8220;The Care and Feeding of Git&#8221; chapter).</p>


	<p>So let&#8217;s see what happens if we rebase rather than merge in the same scenario.  Here we have our first merge and we can see that it orphans <em>Commit 1</em> and applies the changes between <em>Commit 0</em> and <em>Commit 1</em> to the files in <em>Remote Commit 1</em>, creating a new <em>Commit 2</em>.</p>


	<p><img src="vector/Rebase3.eps" alt="" /></p>


	<p>Then, as you&#8217;ll remember, you and Jen both commit again.  You&#8217;ll notice that now it looks like she cloned you and committed and then you changed that code, rather than you both working at the same time and merging.</p>


	<p><img src="vector/Rebase4.eps" alt="" /></p>


	<p>At this point, instead of merging two more times like we did originally, we rebase the next two commits she makes.</p>


	<p><img src="vector/Rebase5.eps" alt="" /></p>


	<p><img src="vector/Rebase6.eps" alt="" /></p>


	<p>And finally, we are left with a commit history that looks like Figure 1, rather than Figure 2, which is what we would have if we had merged instead.</p>


	<p><img src="vector/Rebase7_Final.eps" alt="" /></p>


	<p>note. You should remember to only do this on local branches before you push or on repositories that nobody has fetch access to &#8211; if anyone pulls down the objects that will become abandoned during a rebase, it gets a bit frustrating.</p>


	<h3>Use Cases</h3>


	<p>So why is this helpful, exactly?  It means that you can keep your development cycles loosely coupled.  Here is an example of a common workflow with cheap branches.</p>


	<p>You have a &#8216;master&#8217; branch that is <em>always</em> stable &#8211; you never merge anything into it that you wouldn&#8217;t put into production. Then you have a &#8216;development&#8217; branch that you merge any experimental code into before you imagine pulling it into the &#8216;master&#8217; branch.</p>


	<p>You create a new branch each time you begin to work on a story or feature, branching it off your current &#8216;development&#8217; branch each time, so if you get blocked and need to put it on hold, it doesn&#8217;t effect anything else.  When you do get back to them, you rebase them to the current &#8216;development&#8217; and it is just like you started from there.  Often times you merge the branch back into &#8216;development&#8217; and delete it the same day that you created it.</p>


	<p>If you get a huge project or idea &#8211; say refactoring the entire code base to the newest version of your framework or switching database vendors or something, you create a long-term branch, continuously rebase it to keep it in line with other development, and once everything is tested and ready, merge it in with your master.</p>


	<p>Working with others is unbelievably easy. You ask in an <span class="caps">IRC</span> room if someone has implemented a feature in a library you are using.  Turns out that someone has and you are sent the <span class="caps">URL</span> of their public Git repo for that project.  You add it as a remote, fetch it, create a new &#8216;merge-feature&#8217; branch off your &#8216;development&#8217; branch, merge in the new changes and you&#8217;re done.  No emailing patches around and applying them &#8211; just add contributors as a remote and try out their branches before deciding to merge them in. If it breaks things or is not a good patch, you simply delete the &#8216;merge-feature&#8217; branch and that&#8217;s it.</p>


	<p><img src="bitmap/branching.png" alt="" /></p>


	<p><em>(example of project collaboration using multiple branch forks and merges)</em></p>


	<p>You branch and rebase or merge several times a day in and out of several different branches, some of which last for hours and some are continually there.  Once you get used to this pattern, it completely changes the way you approach your development and the way you contribute and collaborate.</p>


	<h2>The Treeish</h2>


	<p>Besides branch heads, there are a number of shorthand ways to refer to particular objects in the Git data store.  These are often referred to as a <em>treeish</em>.  Any Git command that takes an object &#8211; be it a commit, tree or blob &#8211; as an argument can take one of these shorthand versions as well.</p>


	<p>I will list here the most common, but please read the 
<a href="http://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html">rev-parse command</a>
for full descriptions of all the available syntaxes.</p>


	<h4>Full <span class="caps">SHA</span></h4>


	<p>code. dae86e1950b1277e545cee180551750029cfe735</p>


	<p>You can always list out the entire <span class="caps">SHA1</span> value of the object to reference it.  This is sometimes easy if you&#8217;re copying and pasting values from a tree listing or some other command.</p>


	<h4>Partial <span class="caps">SHA</span></h4>


	<p>code. dae86e</p>


	<p>Just about anything you can reference with the full <span class="caps">SHA</span> can be referenced fine with the first 6 or 7 characters.  Even though the <span class="caps">SHA</span> is always 40 characters long, it&#8217;s very uncommon for more than the first few to actually be the same.  Git is smart enough to figure out a partial <span class="caps">SHA</span> as long as it&#8217;s unique.</p>


	<h4>Branch or Tag Name</h4>


	<p>code. master</p>


	<p>Anything in <em>.git/refs/heads</em> or <em>.git/refs/tags</em> can be used to refer to the commit it points to.</p>


	<h4>Date Spec</h4>


	<p>code. master@{yesterday}
master@{1 month ago}</p>


	<p>This example would refer to the value of that branch yesterday. Importantly, this is the value of that branch <em>in your repository</em> yesterday.  This value is relative to your repo &#8211; your &#8216;master@{yesterday}&#8217; will likely be different than someone else&#8217;s, even on the same project, whereas the <span class="caps">SHA</span> values will <em>always</em> point to the same commit in every copy of the repository.</p>


	<h4>Ordinal Spec</h4>


	<p>code. master@{5}</p>


	<p>This indicates the 5th prior value of the master branch.  Like the <em>Date Spec</em>, this depends on special files in the <em>.git/log</em> directory that are written during commits, and is specific to <em>your</em> repository.</p>


	<h4>Carrot Parent</h4>


	<p>code. e65s46<sup>2
master</sup>2</p>


	<p>This refers to the Nth parent of that commit.  This is only really helpful for commits that merged two or more commits &#8211; it is how you can refer to a commit other than the first parent.</p>


	<h4>Tilde Spec</h4>


	<p>code. e65s46</sub>5</p>


	<p>The tilde character, followed by a number, refers to the Nth generation grandparent of that commit.  To clarify from the carrot, this is the equivalent commit in carrot syntax:</p>


	<p>code. e65s46<sup>^^</sup><sup></p>


	<p><img src="vector/Treeish.eps" alt="" /></p>


	<h4>Tree Pointer</h4>


	<p>code. e65s46</sup>{tree}</p>


	<p>This points to the tree of that commit.  Any time you add a <sup>{tree} to any commit-ish, it resolves to its tree.</p>


	<h4>Blob Spec</h4>


	<p>code. master:/path/to/file</p>


	<p>This is very helpful for referring to a blob under a particular commit or tree.</p>


	<h2>The Git Directory</h2>


	<p>When you initialize a Git repository, either by cloning an existing one or creating a new one, the first thing Git does is create a &#8220;Git Directory&#8221;.  This is the directory that stores all the object data, tags, branches, hooks and more.  Everything that Git permanently stores goes in this single directory.  When you clone someone else&#8217;s repository, it basically just copies the contents of this directory to your computer.  Without a checkout (called a &#8220;working directory&#8221;) this is called a &#8220;bare&#8221; Git repo and moving it to another computer backs up your entire project history.  It is the soul of Git.</p>


	<p>When you run &#8216;git init&#8217; to initialize your repository, the Git directory is by default installed in the directory you are currently in as &#8217;.git&#8217;.  This can be overridden with the <em><span class="caps">GIT</span>_DIR</em> environment variable at any time.  In fact, the Git directory does not need to be in your source tree at all.  It&#8217;s perfectly acceptable to keep all your Git directories in a central place (ex: /opt/git/myproject.git) and just make sure to set the <span class="caps">GIT</span>_DIR variable when you switch projects you are working on (ex: /home/username/projects/myproject).</p>


	<p>The Git directory for our little project looks something like this:</p>


	<p>code. simple-git-dir-tree.txt</p>


	<p>For more in-depth information on the Git directory layout, see the <a href="http://www.kernel.org/pub/software/scm/git/docs/repository-layout.html">git repository layout docs.</a></p>


	<p>For now, let&#8217;s go over some of the more important contents of this directory.</p>


	<h3>.git/config</h3>


	<p>This is the main Git configuration file.  It keeps your project specific Git options, such as your remotes, push configurations, tracking branches and more.  Your configuration will be loaded first from this file, then from a <sub>/.gitconfig file and then from an /etc/gitconfig file, if they exist.</p>


	<p>Here is an example of what a config file might look like:</p>


	<p>code. config-example.txt</p>


	<p>See the <a href="http://www.kernel.org/pub/software/scm/git/docs/git-config.html">git-config</a> docs for more information on available configuration options.</p>


	<h3>.git/index</h3>


	<p>This is the default location of the &#8216;index&#8217; file for your Git project.  This location can be overridden with the <em><span class="caps">GIT</span>_INDEX</em> environment variable, which is sometimes useful for temporary tree operations.  See the chapter on the &#8220;Git Index&#8221; for more information on what this file is used for.</p>


	<h3>.git/objects/</h3>


	<p>This is the main directory that holds the data of your Git objects &#8211; that is, all the contents of the files you have ever checked in, plus your commit, tree and tag objects.</p>


	<p>The files are stored by their <span class="caps">SHA1</span> values.  The first two characters make up the subdirectory and the last 38 is the filename.  For example, if the <span class="caps">SHA</span> for a blob we&#8217;ve checked in was</p>


	<p>code. a576fac355dd17e39fd2671b010e36299f713b4d</p>


	<p>the file we would find the Zlib compressed contents in is:</p>


	<p>code. [GIT_DIR]/objects/a5/76fac355dd17e39fd2671b010e36299f713b4d</p>


	<h3>.git/refs/</h3>


	<p>This directory normally has three subdirectories in it &#8211; <em>heads</em>, <em>remotes</em> and <em>tags</em>.  Each of these directories will hold files that correspond to your local branches, remote branches and tags, respectively.</p>


	<p>For example, if you create a &#8216;development&#8217; branch, the file .git/refs/heads/development will be created and will contain the SHAof the commit that is the latest commit of that branch.</p>


	<h3>.git/HEAD</h3>


	<p>This file holds a reference to the branch you are currently on.  This basically tells Git what to use as the parent of your next commit.  The contents of it will generally look like this:</p>


	<p>code. ref: refs/heads/master</p>


	<h3>.git/hooks</h3>


	<p>This directory contains shell scripts that are invoked after the Git commands they are named after.  For example, after you run a commit, Git will try to execute the <em>post-commit</em> script, if it has executable permissions.</p>


	<p>See the 
<a href="http://www.kernel.org/pub/software/scm/git/docs/hooks.html">online hooks documentation</a>
for more information on what you can do with hooks.</p>


	<h2>Working Directory</h2>


	<p>The working directory is the checkout of the current branch you are working on.  What is really important to note here is that this code is a working copy &#8211; it is not really important.</p>


	<p>This is something that developers from most other SCMs have a hard time understanding and tends to scare them mightily.  If you check out a different branch, git will basically make your working directory look like that branch, removing any checked in content that is currently in your working directory that is not in the new tree.  This is why Git will only let you checkout another branch if everything is checked in &#8211; there are no uncommitted modified files.  The reason for this is that Git will remove files that are not necessary in the branch you are checking out &#8211; it needs to make sure that you can get them back again.</p>


	<p>Most users don&#8217;t like to see content automatically removed from their directories, but that&#8217;s one of the mental shifts you&#8217;ll need to make.  Your working directory is temporary &#8211; everything is stored permanently in your git repository.  Your working directory is just a copy of a tree so you can edit it and commit changes.</p>


	<h2>The Index</h2>


	<p>Git has two places that content states are stored.  The working directory stores one state at a time in a human editable format.  When committed, that state becomes permanent and repeatable by being stored in the object database.  However, how do you determine what changes in your working directory goes into your next commit.  Perhaps you have edited 3 files and you want 2 to go into the first commit because they are related changes and the other file into a second commit.  This is where the index file comes in.</p>


	<p>The index was called the cache for a while, because that&#8217;s largely what it does.  It is a staging area for changes that are made to files or trees that are not committed to your repository yet.  It acts as sort of a middle ground between your working directory and your repository.  What is in it when you run &#8216;git commit&#8217; is what the tree that your commit object points to will look like.</p>


	<p>note.  Early on, the index was called the &#8216;cache&#8217; or the &#8216;current directory cache&#8217;</p>


	<p>It is also used to speed up some operations. It keeps track of the state of all the files in your working directory so you can quickly see what has been modified since the last commit.</p>


	<h2>Non-SCM Uses of Git</h2>


	<p>I keep saying that Git is primarily a content tracking toolkit with <span class="caps">SCM</span> tools built on top of it.  So, if it&#8217;s not built specifically to be an <span class="caps">SCM</span>, perhaps it would be useful to see some other examples of things it might be good for.</p>


	<p>This is a simple listing of some other tools that have been built on Git internals to demonstrate that an <span class="caps">SCM</span> is the bundled application, but Git can also be a useful toolkit for any application needing to track and manage slowly changing distributed trees of content.</p>


	<h3>Peer to Peer Content Distribution Network</h3>


	<p>Imagine you are a retail chain or university campus and have a network of digital signage displays that play flash content advertisements or show campus news, etc.  You have to get new content out to them every day or two, which may consist of any combination of <span class="caps">XML</span> files, images, animations, text and sound.</p>


	<p>You need to build a content distribution framework that will easily and efficiently transfer all the necessary content to the machines on your network.  You need to constantly determine what content each machine has and what it needs to have and transfer the difference as efficiently as possible, because networking to these units may be spotty.</p>


	<p>It turns out that Git is an excellent solution to this problem.  You can simply check all the needed content into Git, create a branch for each unit and point that branch to the exact subtree of content it needs.  Then at some interval, you have the unit fetch its branch.  If nothing has changed, nothing happens &#8211; if content has changed somehow, it gets only the files it does not already have in a delta compressed package and then expands them locally.  Log and status files could even be transferred back by a push.</p>


	<p>An example of a media company actually using this approach is <a href="http://reactrix.com/">Reactrix</a>, which also happens to be where I work.</p>


	<p>note.  Somewhat interestingly, Git being a good solution to this problem is what exposed me to the tool in the first place.  We were using Git for content distribution on our network since the 1.0 release back in 2005, but actually using Perforce for version control internally.  It wasn&#8217;t until nearly a year later that we switched to actually using it to manage our source code.</p>


	<h3>Distributed Document Oriented Database</h3>


	<p>Using Git as a backend for a document oriented database could have some interesting applications.  Git provides a number of features such as replication, searching with grep, and full versioning history for free.</p>


	<h4>Distributed Wiki</h4>


	<p>Let&#8217;s say we wanted to have a wiki for documentation on a project we&#8217;re working on.  If we create a wiki that works off of files, we can simply write those files into a Git repository and run a commit after every change.  This gives us good performance, since it&#8217;s just reading the content off the disk, and full file version history and easy &#8216;recently changed&#8217; data.  We also get searching built in and can edit the wiki offline.</p>


	<p>The other cool feature we could use is the distributed nature of it.  We could add other people on the project as remote repositories and push to and fetch from them, merging changes to write a book or documentation collaboratively.  We could branch to try out a re-write and then either merge it in or throw it away if we don&#8217;t like it.  We could send a pull request to our collegues for them to try out the branch to preview it before we decide whether to merge it in or not.</p>


	<p>It&#8217;s possible the entire wiki project could even live in a bare branch (that is, a branch with no common ancestors with any existing branch) in the same repository as our project, so clones can get the documentation as well, without it muddying up our code tree.</p>


	<p>See the <a href="http://github.com/al3x/git-wiki/tree/master">git-wiki</a> project for an example of this.</p>


	<h4>Distributed Issue Tracker</h4>


	<p>Another similar project might be a distributed ticketing system, where all the tickets (bugs and features) for a project could be stored in a Git repository, worked on offline and transferred with a project.</p>


	<p>Examples of projects trying to do this are 
<a href="http://ditz.rubyforge.org/">Ditz</a>, <a href="http://gitorious.org/projects/kipling">Kipling</a> and my own 
<a href="http://github.com/schacon/ticgit/wikis">TicGit</a>.</p>


	<h3>Backup Tool</h3>


	<p>Let&#8217;s say you want to build something like a distributed Time-Machine (Apple all rights reserved) that efficiently packs up its backups and transfers them to multiple machines.  I&#8217;m hoping by now that you could see the benefits of using the Git toolkit to accomplish this, but this particular problem is interesting because of something that Git doesn&#8217;t do, which is permissions.  Git stores the mode of its content in the tree, but it doesn&#8217;t store any permissions data, which means it&#8217;s not good for backing up directories in which permissions are important, like &#8217;/etc&#8217; for example.</p>


	<p>One project that has tackled this is <a href="http://eigenclass.org/hiki/gibak-backup-system-introduction">Gibak</a>, by implementing a metastore in OCaml, and it&#8217;s worth a look if this topic interests you.</p>


	<p>note.  If you are interested in using Git in a non-standard way and like Ruby, you might be interested in using my <a href="http://jointheconversation.org/rubygit/">&#8216;git&#8217; gem</a>, which provides an object oriented interface in Ruby to the Git tools, including several of the lower level functions.</p>


	<h1>Section Two &#8211; Using Git</h1>


	<p>Now that you <em>hopefully</em> understand what Git is designed to do at a fundamental level &#8211; how it tracks and stores content, how it stores branches and merges and tracks remote copies of the repository, let&#8217;s see how to actually use it.  This next section presents some of the basic commands that you will need to know in order to use Git effectively.</p>


	<p>At the end of each chapter, there will be a link to the official Git documentation for each of the commands used in that section, in case you want to learn more or see all the options for that command.</p>


	<h2>Setting Up Your Profile</h2>


	<p>todo. sidebar:c1-init.textile</p>


	<p>For every commit you do, Git will try to associate a name and email address.  One of the first things you&#8217;ll want to do in Git is to set these values.  You can set them as global configuration values with the &#8216;git config&#8217; command:</p>


	<p>shell. $ git config&#8212;global user.name &#8220;Scott Chacon&#8221; 
$ git config&#8212;global user.email &#8220;schacon@gmail.com&#8221;</p>


	<p>That will create a new &#8216;</sub>/.gitconfig&#8217; file that will now look like this:</p>


	<p>shell. git-config.txt</p>


	<p>You can change those variables at any time either by editing that file, or running the &#8216;git config&#8217; commands again.</p>


	<p>If you want to set different values for a specific project, just leave out the &#8216;&#8212;global&#8217; and it will write the same snippet into your &#8217;.git/config&#8217; file in that repository, which will overwrite your global values.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-config.html">git config</a></li>
	</ul>


	<h2>Getting a Git Repository</h2>


	<p>There are two major ways you will get a Git repository &#8211; you will either clone an existing project, or you will initialize a new one.</p>


	<h3>New Repositories</h3>


	<p>To create a new Git repository somewhere, simply go to the directory you want to add version control to and type:</p>


	<p>shell. git init</p>


	<p>This will create a <em>.git</em> directory in your current working directory that is entirely empty.  If you have existing files you want to add to your new repository, type:</p>


	<p>shell. git add .
git commit -m &#8216;my first commit&#8217;</p>


	<p>This will add all of your current files into your new repository and index and then create your first commit object, pointing your new &#8216;master&#8217; branch to it.  Congratulations, you have now added your source code to Git.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-init.html">git init</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-commit.html">git commit</a> </li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-add.html">git add</a></li>
	</ul>


	<h3>Cloning a Repository</h3>


	<p>Many times you will be <em>cloning</em> a repository, however.  This means that you are creating a complete copy of another repo, including all of its history and published branches.</p>


	<p>note.  A clone is, for all intents and purposes, a full backup.  If the server that you cloned from has a hard disk failure or something equally catastrophic, you can basically take any of the clones and stick it back up there when the server is restored without anyone really the worse for wear.</p>


	<p>In order to do this, you simply need a <span class="caps">URL</span> that has a Git repository hosted there, which can be over <em>http</em>, <em>https</em>, <em>ssh</em> or the special <em>git</em> protocol. We will use the public hosted repository of the simple library I mentioned at the beginning of the book.</p>


	<p>shell. git clone git://github.com/schacon/simplegit.git</p>


	<p>This will by default create a new directory called &#8216;simplegit&#8217; and do an initial checkout of the &#8216;master&#8217; branch.  If you want to put it in a different directory than the name of the project, you can specify that on the command line, too.</p>


	<p>shell. git clone git://github.com/schacon/simplegit.git my_directory</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-clone.html">git clone</a></li>
	</ul>


	<h2>Normal Workflow Examples</h2>


	<p>Now that we have our repository, let&#8217;s go through some normal workflow examples of a single person developing.</p>


	<p>todo. sidebar:c2-normal-workflow.textile</p>


	<h3>Ignoring</h3>


	<p>First off, we will often want Git to automatically ignore certain files &#8211; often ones that are automatically generated during our development.  For example, in Rails development we often want to ignore the log files, the production specific configuration files, etc. To do this, we can add patterns into the <em>.gitignore</em> file to tell Git that we don&#8217;t want it to track them.</p>


	<p>Here is an example <em>.gitignore</em> file.</p>


	<p>code. gitignore.txt</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/gitignore.html">.gitignore</a></li>
	</ul>


	<h3>Adding and Committing</h3>


	<p>Now we&#8217;ll do some development and periodically commit our changes.  We have a few options here &#8211; we can commit individual files or we can tell the <em>commit</em> command to automatically add all modified files in our working directory to the index, then commit it.</p>


	<p>A good way to find out what you&#8217;re about to commit (that is, what is in your index) is to use the &#8216;status&#8217; command.</p>


	<p>shell. git-status.txt</p>


	<p>In this example, I can see that I&#8217;ve modified three files in my working directory, but none of them have been added to the index yet &#8211; they are not staged and ready to be committed.  If I want to make these changes in two separate commits, or I have completed work on some of them and would like to push that out, I can specify which files to add individually and then commit.</p>


	<p>shell. git-add-status.txt</p>


	<p>You can see that if we commit at this point, only the Rakefile will show up as changed in the commit.</p>


	<p><img src="vector/Git_Add_Commit.eps" alt="" /></p>


	<p>If we want to commit all our changes, we can use this shorthand, which will automatically run a &#8216;git add&#8217; on every modified file to our index, then commit the whole thing:</p>


	<p>shell. $ git commit -a -m &#8216;committing all changes&#8217;</p>


	<p><img src="vector/Git_Commit_A.eps" alt="" /></p>


	<p>If you would like to give a more useful commit message, you can leave out the &#8216;-m&#8217; option.  That will fire up your $EDITOR to add your commit message.</p>


	<p>note. Give special care to the first line of your commit message &#8211; it will often be the only thing people see when they are looking through your commit history.</p>


	<p>Now we can continue this loop &#8211; modifying, adding and committing &#8211; during our development.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-status.html">git status</a></li>
	</ul>


	<h3>Interactive Adding</h3>


	<p>Although that will work for all of your development needs &#8211; many developers simply use &#8216;-a&#8217; nearly every time they commit to just automatically add everything to the index, there is another way of adding files that makes for a more controlled and thematic set of commits.  This is called &#8216;interactive&#8217; adding, and it is a very powerful tool to controlling what goes into each commit.</p>


	<p>todo. sidebar:c3-add-interactive.textile</p>


	<p>Let&#8217;s say we add a new function to our &#8216;lib/simplegit.rb&#8217; file, add a new task to our &#8216;Rakefile&#8217; and then add a new &#8216;TODO&#8217; file to our project.  Later we come back and want to commit, but we don&#8217;t remember which files had to do with each other and we don&#8217;t just want to commit them all together because that&#8217;s confusing for collaborators trying to review our code. &#8216;Interactive&#8217; mode let&#8217;s us modify our index interactively before committing.  To fire it up, type &#8216;git add -i&#8217;:</p>


	<p>shell. interactive-mode1.txt</p>


	<p>We can see that we have two files that are being tracked (have been added at some point in the past) that have been modified.  We cannot yet see our new <span class="caps">TODO</span> file, though.  To add that, type &#8216;4&#8217; for the &#8216;add untracked&#8217; option and hit enter.</p>


	<p>shell. interactive-mode2.txt</p>


	<p>You will see all the untracked files in your working directory.  Type the numbers of the files you want to add, or a range (ie: &#8216;1-5&#8217;), and hit enter twice when you&#8217;re done. This will drop you back to the main menu.  You can then type &#8216;1&#8217; to see what your index looks like now.</p>


	<p>shell. interactive-mode3.txt</p>


	<p>You can see that the <span class="caps">TODO</span> file is now staged (in the index), but the other two are not.  Let&#8217;s add the Rakefile, but not the &#8216;lib/simplegit.rb&#8217; file and commit it. To do that, we hit &#8216;2&#8217;, which lists the files we can update, type &#8216;1&#8217; and enter to add the Rakefile, then hit enter again to go back to the main menu.  Then we hit &#8216;7&#8217; to exit and run the &#8216;git commit&#8217; command</p>


	<p>shell. interactive-mode4.txt</p>


	<p>The interactive shell is pretty simple and very powerful &#8211; playing with it instead of running &#8216;git add&#8217; commands directly may help in understanding what&#8217;s happening, since you can see the status of your files in the index versus the working directory more clearly.  It helps visualize that what is in your index (the &#8216;staged&#8217; column) is what will be committed when you run &#8216;git commit&#8217;.</p>


	<p>You can also do more complicated things, like going through all of your change patches hunk by hunk, deciding if each hunk should be applied to the next commit or not.  This means that if you&#8217;ve made a bunch of changes to one file, you can commit <em>part</em> of those changes in one commit, and the rest in a second.  Try the &#8216;patch&#8217; menu option in the Interactive Adding menu to try this out.</p>


	<p>note.  Beware of using interactive adding if you are already used to running &#8216;git commit -a&#8217;.  If you run through the whole interactive add process and then run &#8216;git commit -a&#8217;, it will basically ignore everything you just did and just add all modified files.</p>


	<h4>Removing</h4>


	<p>For removing files from your tree, you can simply run:</p>


	<p>shell. git rm <filename></p>


	<p>which will remove that file from the index (and thus from the next commit) as well as from your working directory.  On your next commit, the tree that commit points to will simply not contain that file anymore.</p>


	<h2>Log &#8211; the Commit History</h2>


	<p>So, now we have all this history in our Git repository.  So what?  What can we do with it?  How can we see this history?</p>


	<p>todo. sidebar:c4-git-log.textile</p>


	<p>The answer is the very powerful <em>git log</em> command.  The &#8216;log&#8217; command can show you nearly anything you want to know about your commit history.  Also, since the entire history is stored locally, it&#8217;s really fast compared with most other <span class="caps">SCM</span> systems (especially if your repository is packed &#8211; see &#8220;Care and Feeding&#8221; chapter)</p>


	<p>If you just run <em>git log</em>, you will get output like this:</p>


	<p>shell. git-log.txt</p>


	<p>This will show you the SHAof each commit, the committer and date of the commit, and the full message, starting from the last commit on your current branch and going backward in reverse chronological order (so if there are multiple parents, it just squishes them together, interleaving the commits ordered by date)</p>


	<h3>Formatting Log Output</h3>


	<p>The default format takes up a lot of space though, so there are ways to limit and format this output differently.  &#8216;&#8212;pretty&#8217; is a useful option for formatting the output in different ways.</p>


	<p>For example, we can list the commit shas and the first line of the message with &#8216;&#8212;pretty=oneline&#8217;:</p>


	<p>shell. git-log-oneline.txt</p>


	<p>With &#8216;&#8212;pretty&#8217;, you can choose between <em>oneline</em>, <em>short</em>, <em>medium</em>, <em>full</em>, <em>fuller</em>, <em>email</em>, <em>raw</em> and <em>format:(string)</em>, where (string) is a format you specify with variables (ex:&#8212;format:&#8221;%an added %h on %ar&#8221; will give you a bunch of lines like &#8216;Scott Chacon added f1cc9df 4 days ago&#8217;)</p>


	<h3>Filtering Log Output</h3>


	<p>There are also a number of options for filtering the log output.  You can specify the maximum number of commits you want to see with &#8216;-n&#8217;, you can limit the range of dates you want to see commits for with&#8212;since and&#8212;until, you can filter it on the author or committer, text in the commit message and more.  Here is an example showing at most 30 commits between yesterday and a month ago by me :</p>


	<p>shell. git log -n 30&#8212;since=&#8221;1 month ago&#8221;&#8212;until=yesterday&#8212;author=&#8221;schacon&#8221;</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-log.html">git log</a></li>
	</ul>


	<h2>Browsing Git</h2>


	<p>Git also gives you access to a number of lower level tools that can be used to browse the repository, inspect the status and contents of any of the objects, and are generally helpful for inspection and debugging.</p>


	<p>todo. sidebar:c5-git-browsing.textile</p>


	<h3>Showing Objects</h3>


	<p>The &#8216;git show&#8217; command is really useful for presenting any of the objects in a very human readable format.  Running this command on a file will simply output the contents of the file.  Running it on a tree will just give you the filenames of the contents of that tree, but none of its subtrees.  Where it&#8217;s most useful is using it to look at commits.</p>


	<h4>Showing Commits</h4>


	<p>If you call it on a tree-ish that is a commit object, you will get simple information about the commit (the author, message, date, etc) and a diff of what changed between that commit and its parents.</p>


	<p>shell. git-show-commit.txt</p>


	<h4>Showing Trees</h4>


	<p>Instead of the &#8216;git show&#8217; command, it&#8217;s generally more useful to use the lower level &#8216;git ls-tree&#8217; command to view trees, because it gives you the shas of all the blobs and trees that it points to.</p>


	<p>shell. git-lstree1.txt</p>


	<p>You can also run this command recursively, so you can see all the subtrees as well.  This is a great way to get the SHAof any blob anywhere in the tree without having to walk it one node at a time.</p>


	<p>shell. git-lstree2.txt</p>


	<p>The &#8216;-t&#8217; makes it also show the shas of the subtrees themselves, rather than just all the blobs.</p>


	<h4>Showing Blobs</h4>


	<p>Lastly, you may want to extract the contents of individual blobs.  The &#8216;cat-file&#8217; command is an easy way to do that, and can also serve to let you know what type of object a SHAis, if you happen to not know.  It is sort of a catch-all command that you can use to inspect objects.</p>


	<p>shell. git-catfile.txt</p>


	<p>With those basic commands, you should be able to explore and inspect any object in any git repository relatively easily.</p>


	<h3>Graphical Interfaces</h3>


	<p>There are two major graphical interfaces that come with Git as tools to browse the repository.</p>


	<h4>Gitk</h4>


	<p>A very popular choice for browsing Git repositories is the Tcl/Tk based browser called &#8216;gitk&#8217;.  If you want to see a simple visualization of your repository, gitk is a great tool.</p>


	<p><img src="s2/gitk.png" alt="" /></p>


	<p>Gitk will also take most of the same arguments that &#8216;git log&#8217; will take, including &#8216;<del>-since&#8217;, &#8216;</del>-until&#8217;, &#8216;&#8212;max-count&#8217;, revision ranges and path limiters.  One of the most interesting visualizations that I regularly use is &#8216;gitk&#8212;all&#8217;, which will show you all of your branches (rather than just the one you are currently on) next to each other.</p>


	<h4>Instaweb</h4>


	<p>If you don&#8217;t want to fire up Tk, you can also browse your repository quickly via the &#8216;git instaweb&#8217; command.  This will basically fire up a web server running the <a href="http://git.or.cz/gitwiki/Gitweb">gitweb</a> cgi script using lighttpd, apache or webrick.  It then tries to automatically fire up your default web browser and points it at the new server.</p>


	<p>shell. git-instaweb.txt</p>


	<p><img src="./s2/instaweb.png" alt="" /></p>


	<p>When you are done, you can run the following to shut down the server.</p>


	<p>shell. $ git instaweb&#8212;stop</p>


	<p>This is a quick way to throw up a web interface on your git repository for sharing with others or simply browsing it in a different way.</p>


	<p>For a more long term web interface to your repository, you can put the gitweb perl files that come with Git into your cgi-bin directory.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-show.html">git show</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-ls-tree.html">git ls-tree</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-cat-fileÃŸ.html">git cat-file</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/gitk.html">gitk</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-instaweb.html">git instaweb</a></li>
	</ul>


	<h2>Searching Git</h2>


	<p>Git has an easy way for searching through trees in your repository without having to check them out into your working directory to do it manually.  It is called &#8216;git-grep&#8217; and works very much like the traditional <span class="caps">UNIX</span> &#8216;grep&#8217; command, with the difference that instead of listing the files you want to search as an argument, you list the trees you want to search.</p>


	<p>For example, if we wanted to search for the string &#8216;log_syslog&#8217; in versions 1.0 and 1.5.3.8 of the Git source code in the C files only, we can find that very easily.</p>


	<p>shell. git-grep.txt</p>


	<p>You can see that you can view the number of lines that match, or the actual lines, and you can list as many trees (in this case, I used tags to reference them) as you want to search.</p>


	<p>Another interesting example is to see which files in these versions do not contain the string &#8216;git&#8217; anywhere in them:</p>


	<p>shell. git-grep2.txt</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-grep.html">git grep</a></li>
	</ul>


	<h2>Git Diff</h2>


	<p>Git has a great diff utility built in that can give you statistics or a patch file given any combination of tree objects, working directory and index.</p>


	<p>Two common uses of this include seeing what you&#8217;ve worked on but not committed yet, and creating a patch file to send to someone over email (though there is a much preferred way to share changes which we will learn about in the &#8220;distributed workflow&#8221; section a bit later).</p>


	<h3>What has changed?</h3>


	<p>If you simply run &#8216;git diff&#8217; with no arguments, it will show you the differences between your current working directory and your index, that is, the last time you ran &#8216;git add&#8217; on your files.</p>


	<p>For example, if I add my email to the <span class="caps">README</span> file and run it, I will see this:</p>


	<p>shell. git-diff-readme.txt</p>


	<p>You can also use &#8216;git diff&#8217; to show you some spiffy stats for a diff, rather than a patch file, if you want to see a wider overview of what changed, then drill down into specific files later.  Here are some examples getting stats, the first for the differences between two commits and the second a summary between a commit and the current <span class="caps">HEAD</span>.</p>


	<p>shell. git-diff-stat.txt</p>


	<p>If you want to see what the specific difference is in one of those files, you can just add a path limiter to the diff command.</p>


	<p>shell. git-diff-file.txt</p>


	<p>You can use this command to detect changes between your index and any tree, or your working directory and any tree, your working directory and your index, etc.</p>


	<h3>Generating Patch Files</h3>


	<p>The default output of the &#8216;git diff&#8217; command is a valid patch file.  If you pipe the output into a file and email it to someone, they can apply it with the &#8216;patch&#8217; command.  If you&#8217;ve done some work off of a project in an &#8216;experiment&#8217; branch, you could create a patch file this way:</p>


	<p>shell. $ git diff master..experiment &gt; experiment.patch</p>


	<p>You can then email that file to anyone, who could apply it with the &#8216;-p1&#8217; argument:</p>


	<p>shell. $ patch -p1 &lt; ~/experiment.patch 
patching file lib/simplegit.rb</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-diff.html">git diff</a></li>
	</ul>


	<h2>Branching</h2>


	<p>This is the fun part of Git that you&#8217;ll come to love like a child. When you first initialize a git repository, or clone one, you&#8217;ll get a &#8216;master&#8217; branch by default if you don&#8217;t specify something else.  This is really just a git suggestion and you don&#8217;t have to use it &#8211; like just about everything in Git, it can be overridden.</p>


	<h3>Switching Branches</h3>


	<p>However, let&#8217;s say we&#8217;re working on our project and we want to add a new function to our library, so we&#8217;ll make a new branch called &#8216;newfunc&#8217; and switch to it.  There are two ways we can do this, one is to create the branch and then switch to it:</p>


	<p>shell. $ git branch newfunc; git checkout newfunc</p>


	<p>The other way is to checkout a branch that doesn&#8217;t exist yet and tell git you want to create it by passing the &#8216;-b&#8217; flag:</p>


	<p>shell. $ git checkout -b newfunc</p>


	<p>Now, to check which branch we are on, we just type &#8216;git branch&#8217;:</p>


	<p>shell. git-branch.txt</p>


	<p>We can see we are now on our new branch.  This means that if we modify a file and commit it, this branch will include that change, but the &#8216;master&#8217; branch will not have it yet.  So, we add a new method to our library and commit it.</p>


	<p>shell. $  vim lib/simplegit.rb; git commit -a -m &#8216;added lstree function&#8217;
Created commit 1a8c32e: added lstree function
 1 files changed, 4 insertions(+), 0 deletions(-)</p>


	<p>Now we want to change something in the <span class="caps">README</span> in the &#8216;master&#8217; branch, but we haven&#8217;t tested this function yet so we don&#8217;t want to merge our new branch in yet.  That&#8217;s fine, we just switch back and make the change.</p>


	<p>shell. git-checkout-master-work.txt</p>


	<p>Now lets see what the differences in our branches are.</p>


	<p>shell. git-branch-diff.txt</p>


	<p>We could also get a patch file for one to apply to the other, but what we really want to do next is merge the two.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-branch.html">git branch</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-checkout.html">git checkout</a></li>
	</ul>


	<h2>Simple Merging</h2>


	<p>todo. sidebar:c6-branch-merge.textile</p>


	<p>So now we want to move the changes in our &#8216;newfunc&#8217; branch back into our &#8216;master&#8217; branch and remove it.  This will require us merging one branch into another.  Since we&#8217;re already in our &#8216;master&#8217; branch, we&#8217;ll merge in the &#8216;newfunc&#8217; branch like this:</p>


	<p>shell. $ git merge newfunc</p>


	<p>Easy peasy.  We can see that the simplegit.rb file now has 4 new lines and the <span class="caps">README</span> file was auto-merged.</p>


	<p>Now we can get rid of our &#8216;newfunc&#8217; branch with a simple:</p>


	<p>shell. $ git branch -d newfunc
Deleted branch newfunc.</p>


	<h3>Resolving Conflicts</h3>


	<p>That was a fairly simple problem, but what if we branch our code and then edit the same place in a file in different ways in each branch?  In that case, we&#8217;ll get a conflict when we try to merge them back together.  Git is not too aggressive in trying to resolve conflicts, since you don&#8217;t want it to make assumptions that are not necessarily correct, so bugs aren&#8217;t introduced without your knowledge.</p>


	<p>Let&#8217;s say that we created a &#8216;versioning&#8217; branch and then modified the version in the Rakefile to different versions in both the new branch and the &#8216;master&#8217; branch, then tried to merge them together.</p>


	<p>shell. merge-conflict.txt</p>


	<p>It tells us that there was a conflict and so the new commit object was not created.  We will have to merge the conflicted file manually and then commit it again.  The output tells us the files that had conflicts, in this case it was the Rakefile.</p>


	<p>ruby. rakefile.rb</p>


	<p>We can see that in the &#8216;master&#8217; branch, the version was changed to &#8216;0.1.2&#8217; and in the &#8216;versioning&#8217; branch, the same line was changed to &#8216;0.2.0&#8217;.  All we have to do is choose which one is correct and remove the rest of the lines, like so:</p>


	<p>ruby. rakefile-post.rb</p>


	<p>Now we add and commit that file, and we&#8217;re good.</p>


	<p>shell. $ git add Rakefile 
$ git commit -m &#8216;fixed conflict&#8217;
Created commit 47c668a: fixed conflict</p>


	<h3>Undoing a Merge</h3>


	<p>Assume we have gone through some massive merge because someone on your team hasn&#8217;t committed in a while, or you have a branch that was created some time ago but hasn&#8217;t been rebasing and you want to pull it in.  So you try to &#8216;git merge old_branch&#8217; it and you get conflict after conflict and it is just too much trouble to deal with and you just want to undo it all.</p>


	<p>This is where &#8216;git reset&#8217; comes in.  To reset your working directory and index back to what it was before you tried the merge, simply run:</p>


	<p>shell. $ git reset&#8212;hard <span class="caps">HEAD</span></p>


	<p>The &#8216;&#8212;hard&#8217; makes sure both your index file and working directory are changed to match what it used it be. By default it will only reset your index, leaving the partially merged files in your working directory.  If you happen to have worked through it all and committed, then decided that it was a mistake because all of your tests break or something, you can still go back (and throw away that commit) by running:</p>


	<p>shell. $ git reset&#8212;hard <span class="caps">ORIG</span>_HEAD</p>


	<p>This is only helpful if you want to undo the latest change or changes.  If you happen to commit again then decide that you want to keep the latest commit, but undo a commit that was added sometime before that, you&#8217;ll need to use &#8216;git revert&#8217;, which is a bit too dangerous to cover here.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-branch.html">git branch</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-merge.html">git merge</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-reset.html">git reset</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-revert.html">git revert</a></li>
	</ul>


	<h2>Rebasing</h2>


	<p>todo. sidebar:c7-rebasing.textile</p>


	<p>To review, rebasing is an alternative to merging that takes all the changes you&#8217;ve done since you branched off and applies those changes as patches to where the branch you are rebasing to is now, abandoning your original commit objects.  For clean merges, this is a relatively simple process.  Say we have been working in a branch called &#8216;story84&#8217; and it&#8217;s completed and we want to merge it into the master branch.</p>


	<p><img src="s2/repo1.png" alt="" /></p>


	<p>If we do a simple merge, our history will look like this:</p>


	<p><img src="s2/repo.png" alt="" /></p>


	<p>But we don&#8217;t want to mess up our history with a bunch of branches and merges when it can be clearer.  Instead of running &#8216;git merge story84&#8217; from the master branch, we can stay in the &#8216;story84&#8217; branch and run &#8216;git rebase master&#8217;</p>


	<p>shell. rebase-conflict.txt</p>


	<p>Many times this goes very smoothly and you can see all the new commits and trees written in place of the old ones.  In this case, I had edited the &#8216;lib/simplegit.rb&#8217; file differently in each branch which caused a conflict.  I will have to resolve this conflict before I can continue the rebase.</p>


	<p>This gives us some options, since the rebase can do this at any point &#8211; say you have 8 commits to move onto the new branch &#8211; each one could cause a conflict and you will have to resolve them each manually.  The &#8216;rebase&#8217; command will stop at each patch if it needs to and let you do this.</p>


	<p>You have three things you can do here, you can either fix the file, run a &#8216;git add&#8217; on it and then run a &#8216;git rebase&#8212;continue&#8217;, which will move on to the next patch until it&#8217;s done.  Our second option is to run &#8216;git rebase&#8212;abort&#8217;, which will reset us to what our repo looked like before we tried the rebase. Or, we can run &#8216;git rebase&#8212;skip&#8217;, which will leave this one patch out, abandoning the change forever.</p>


	<p>note.  Git rebase options for a conflict : <strong><del>-continue</strong> : trys to keep going once you&#8217;ve resolved it, <strong></del>-abort</strong> : gives up altogether and returns to the state before the rebase, <strong>&#8212;skip</strong> : skips this patch, abandoning it forever</p>


	<p>In this case we will simply fix the conflict, run &#8216;git add&#8217; on the file and then run &#8216;git rebase&#8212;continue&#8217; which then makes our history look like this:</p>


	<p><img src="s2/repo3.png" alt="" /></p>


	<p>Then all we have to do is switch to the master branch and merge in &#8216;story84&#8217; (which is called a &#8216;fast-forward&#8217;, since &#8216;master&#8217; is now a direct ancestor of &#8216;story84&#8217;) to get this:</p>


	<p><img src="s2/repo4.png" alt="" /></p>


	<h3>Interactive Rebasing</h3>


	<p>Much like Git provides a nicer way to work with your index before committing with &#8216;git add&#8212;interactive&#8217;, there is an interactive rebasing option that can only be fairly described as the &#8220;bee&#8217;s knees&#8221;.</p>


	<p>Assume we have started working on a story to add the &#8216;git add&#8217; functionality to our library and so we&#8217;ve started a new branch called &#8216;story92&#8217; and done the work there.  Then we decide that the &#8216;ls-tree&#8217; function needs to be recursive and make that change, then we tweak the library again, committing each time. Meanwhile we&#8217;ve pulled in a change that implements the same &#8216;ls-tree&#8217; change differently into our &#8216;master&#8217; branch.</p>


	<p><img src="s2/repo-rebasei1.png" alt="" /></p>


	<p>We can see before we try the merge that the same change is in each branch, and I can see that the master branch version is better, so I don&#8217;t even really want to merge it, I just want to throw my change away.  Also, I don&#8217;t really need the other two commits to be two commits, because the second one is just a tweak and should be included in the first one.  Lets use &#8216;git rebase -i&#8217; to rebase this branch and make those changes.  When we run the command, our editor comes up, showing this:</p>


	<p>code. repo-rebase.txt</p>


	<p>Now we can see all of the commits that we are going to rebase.  If we remove the &#8216;made ls-tree recursive&#8217; line, it effectively ditches that commit so we&#8217;ll avoid a conflict and not have to worry about it.  Changing the action on the last line to &#8216;squash&#8217; tells git to just make this and the previous commit into a single commit.  So if we exit the editor with this as the new text:</p>


	<p>code. repo-rebase2.txt</p>


	<p>Then git sees we have squashed two commits and wants us to pick a commit message for it, giving us the commit messages of both for us to create a new one for.</p>


	<p>code. repo-rebase3.txt</p>


	<p>So we stick with the first message, save and exit the editor.</p>


	<p>shell. repo-rebase4.txt</p>


	<p>Now we&#8217;ve rebased and instead of three commits on top of our master and having to reconcile a useless conflict, we&#8217;ve just added a single commit with no resolving neccesary:</p>


	<p><img src="s2/repo-rebasei2.png" alt="" /></p>


	<p>The rebase command is one of the most useful and unique in the git workflow.  To learn more about some spiffy things you can do with it, check out the [History Manipulation] and [Advanced Merging] sections.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-rebase.html">git rebase</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-reset.html">git reset</a></li>
	</ul>


	<h2>Stashing</h2>


	<p>Stashing is a pretty simple concept that is incredibly useful and very easy to use.  If you are working on your code and you need to switch to another branch for some reason and don&#8217;t want to commit your current state because it is only partially completed, you can run &#8216;git stash&#8217;, which will basically take the changes from your last commit to the current state of your working directory and store it temporarily.</p>


	<p>In the following example, I have a change to my &#8216;lib/simplegit.rb&#8217; file, but it&#8217;s not complete.</p>


	<p>shell. stash.txt</p>


	<p>Now I can see that my working directory is clean, as if I had committed, but I did not.  Now I can switch branches, work for a while somewhere else, then switch back. So where did that change go?  How do I get it back?  Well, I can see my stashes by running &#8216;git stash list&#8217;.</p>


	<p>shell. stash-list.txt</p>


	<p>I see I have two stashes on the &#8216;master&#8217; branch, both saved off of working from the same commit, and I have one stashed change off the &#8216;experiment&#8217; branch.  However, I can&#8217;t remember which stash was the one I want, so I can use &#8216;git stash show&#8217; to figure it out.</p>


	<p>shell. stash-show.txt</p>


	<p>I can also use any normal git tools that will take a tree on it, for instance, &#8216;git diff&#8217;:</p>


	<p>shell. stash-diff.txt</p>


	<p>And finally, I can apply it:</p>


	<p>shell. stash-apply.txt</p>


	<p>Now we can see that our working directory is back to where it was, with one file in an unstaged state.  Now I would have to &#8216;git add&#8217; and &#8216;git commit&#8217; it if I wanted to keep the change.</p>


	<p>Normally it&#8217;s not even this complicated.  If you run &#8216;git stash apply&#8217; without the actual stash reference, it will just apply the last stash you saved on that branch.  Normally I will just use &#8216;git stash&#8217; to save something, go work elsewhere, then come back and run &#8216;git stash apply&#8217; to get back to where I was.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-stash.html">git stash</a></li>
	</ul>


	<h2>Tagging</h2>


	<p>As we previously covered, creating a tag in Git is much like making a branch.  A tag in Git serves is basically a signed branch that never moves &#8211; it is simply an arbitrary string that points to a specific commit.</p>


	<p>For example, if you wanted to tag your code base every time you released to production or created a new binary to release, you would run something like this:</p>


	<p>shell. $ git tag -a v0.1 -m &#8216;this is my v0.1 tag&#8217;</p>


	<p>As we recall from section one, that command will create a git object that looks something like this:</p>


	<p><img src="vector/Tag_Expand.eps" alt="" /></p>


	<p>and will store that in the &#8217;.git/objects/&#8217; directory and then will create a permanent reference to it in &#8217;.git/refs/tags/v0.1&#8217; that contains the SHAof that tag.</p>


	<p>Then you can use that as a reference to that commit at any time in commands like &#8216;diff&#8217; or &#8216;archive&#8217; (see next chapter).</p>


	<h3>Lightweight Tags</h3>


	<p>You can also create a tag that doesn&#8217;t actually add a Tag object to the database, but just creates a reference to it in the &#8217;.git/refs/tags&#8217; directory.  If you run the following command:</p>


	<p>shell. $ git tag v0.1</p>


	<p>Git will create the same file as before, &#8217;.git/refs/tags/v0.1&#8217;, but it will contain the SHAof the current <span class="caps">HEAD</span> commit itself, not the SHAof a Tag object pointing to that commit.  Unlike object Tags, these can be moved around easily, which is generally undesirable.</p>


	<h3>Signed Tags</h3>


	<p>At the other end of the tagging spectrum, you can sign Tag object with a <span class="caps">GPG</span> key to ensure its cryptographic integrity.  Replacing &#8216;-a&#8217; with &#8217;-s&#8217; in the command will create a Tag object and sign it with the current users email address <span class="caps">GPG</span> key.  If you want to specify a key, you can run it with &#8216;-u&#8217; instead:</p>


	<p>shell. $ git tag -u <key-id> v0.1 -m &#8216;the 0.1 release&#8217;</p>


	<p>Then, you or others can later verify that signed tag with a &#8216;-v&#8217;</p>


	<p>shell. $ git tag -v v0.1</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-tag.html">git tag</a></li>
	</ul>


	<h2>Exporting Git</h2>


	<p>If you want to create a release of your code, or provide some poor non-git user with a snapshot of just a specific tree, you can use the <strong>git-archive</strong> command.</p>


	<p>note.  &#8216;git-archive&#8217; used to be called &#8216;git-tar-tree&#8217;, in case you ever see that command around in older articles</p>


	<p>You can create the archive in either &#8216;tar&#8217; or &#8216;zip&#8217; formats, the default being &#8216;tar&#8217;.  You can use the &#8216;&#8212;prefix&#8217; argument to determine what directory, if any, the files are expanded into. To create a gzipped tarball, you&#8217;ll have to pipe the output through &#8216;gzip&#8217; first.</p>


	<p>shell. $ git-archive&#8212;prefix=simplegit/ v0.1 | gzip &gt; simple-git-0.1.tgz</p>


	<p>Then, if you email that tarball to someone, they would get this when they opened it:</p>


	<p>shell. git-archive.txt</p>


	<p>You can also archive parts of your project.  This command will create a zip file of just the &#8216;lib&#8217; directory of the first parent of your master branch that will expand out into the current directory:</p>


	<p>shell. $ git-archive&#8212;format=zip master</sup> lib/ &gt; simple-git-lib.zip</p>


	<p>Which will unzip like this:</p>


	<p>shell. git-archive-zip.txt</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-archive.html">git archive</a></li>
	</ul>


	<h2>The Care and Feeding of Git</h2>


	<p>Git requires a bit of tender loving care from time to time.  It may seem a bit odd, but occasionally you should run a few commands on your repositories to make sure they&#8217;re healthy and running as quickly as possible.</p>


	<h3>garbage collection</h3>


	<p>The &#8216;git gc&#8217; command is an important one to remember.  It will pack up your objects into the delta-compressed format, saving you a lot of space and seriously speeding up several commands.</p>


	<p>shell. git-gc.txt</p>


	<p>If can turn gc&#8217;ing automatically on and off by setting a configuration setting to &#8216;1&#8217; or &#8216;0&#8217;:</p>


	<p>shell. $ git config&#8212;global gc.auto 1</p>


	<p>This will make git automatically gc itself occasionally.  You may want to setup a cron to do this at night, however, as it can take a while sometimes on really large repositories.</p>


	<h3>fsck and prune</h3>


	<p>If you want to check the health of your repository, you can run &#8216;git-fsck&#8217;, which will tell you if you have any unreachable or corrupted objects in your database and help you fix them.</p>


	<p>shell. git-fsck.txt</p>


	<p>Which you can then remove with &#8216;git-prune&#8217; (you can run it with &#8216;-n&#8217; first to see what it will do)</p>


	<p>shell. git-prune.txt</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-gc.html">git gc</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-fsck.html">git fsck</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-prune.html">git prune</a></li>
	</ul>


	<h2>Distributed Workflow Examples</h2>


	<p>Now we&#8217;ve gone over most of the basic commands that you&#8217;ll use on a day to day basis as a single developer.  This chapter covers some examples of what you will use in order to collaborate with other developers on a code base.</p>


	<p>todo. sidebar:c8-dist-workflow.textile</p>


	<h3>Cloning</h3>


	<p>If you want to begin working on an existing project, you will need to get an initial version of it &#8211; copy its repository of objects and references to your machine. This is done with a clone.  Git can clone a repository over several transports, including local, http, https, ssh, its own &#8216;git&#8217; protocol, and rsync.  The &#8216;git&#8217; protocol and &#8216;ssh&#8217; are preferred because they are more efficient and not difficult to set up.</p>


	<p>When you clone a repository, it in essence copies all the git objects to a new directory, checks you out a single local branch named the same as the <span class="caps">HEAD</span> branch on the cloned repo (normally &#8216;master&#8217;), and stores all the other branches under a remote reference by default named &#8216;origin&#8217;.</p>


	<p>That means that if we cloned the repo in the previous examples, instead of &#8216;story84&#8217; being a local branch you can switch to, it becomes &#8216;origin/story84&#8217; that you have to create a local branch to pull into in order to work on (eg: &#8216;git checkout&#8212;track story84 origin/story84&#8217;)  
The &#8216;&#8212;track&#8217; indicates that you may want to pull from or push to the origin of this branch later, so remember where it came from.</p>


	<h4>Local Clones</h4>


	<p>Local clones are the simplest types of clones &#8211; it is basically the equivalent of copying the .git directory and doing a checkout.  The only major difference is that it adds all the original branches in as origin branches.  Often you will do this when creating a bare repository (that is, a repository without a working directory) for putting on a public server, or if you&#8217;re working with people using a shared repository over <span class="caps">NFS</span> or something similar.</p>


	<p>shell. $ git clone&#8212;bare simplegit/.git simplegit-bare.git</p>


	<h4><span class="caps">SSH</span> and Git Transports</h4>


	<p>Cloning over ssh requires that you have user credentials on the machine you are cloning from.  The git transport does not have this authentication and so is normally used for fetching only.</p>


	<p>shell. $ git clone git@github.com:schacon/ticgit.git ticgit_directory</p>


	<h4><span class="caps">HTTP</span> and <span class="caps">HTTPS</span> Transports</h4>


	<p>Another popular way to clone a repository is over <span class="caps">HTTP</span>, just because it is so simple.  You don&#8217;t need to setup any special service or give out user credentials (made easier by services like gitosis), you simply scp your bare repository into any web server&#8217;s static content directory.  It is not as efficient as the other protocols &#8211; it will transfer loose objects and packfiles over a number of calls instead of packing them up, but it is simple.</p>


	<p>shell. $ git clone http://git.gitorious.org/piston/mainline.git piston</p>


	<p>Once you have run one of these commands, you will have a copy of the git repository, full of all the history &#8211; basically every blob and tree and commit that project has ever had.  This is really a full backup of the repository &#8211; if the main server ever goes down or gets corrupted, everyone who has ever cloned it has a fully capable backup that can replace it.  With Git, there is really no single point of failure.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-clone.html">git clone</a></li>
	</ul>


	<h3>Fetching and Pulling</h3>


	<p>So let&#8217;s say that we&#8217;re going to hack on TicGit, our git based ticket tracking system project.  After we clone it, we look through the source code but don&#8217;t do anything right away. After some time passes we come back to the project but it may not still be up to date &#8211; changes may have occurred in the meantime.  So we fetch an update.</p>


	<p>shell. $ git fetch origin</p>


	<p>This will contact the server over the same protocol we used to clone it and grab all of the objects and references that have been added since our clone and update our &#8216;origin/[branch]&#8217; branches to point to what the server is pointing at now.</p>


	<p>So, if we did create a tracking branch on &#8216;story84&#8217; and it was changed on the server (someone pushed an update), before we fetch, our local &#8216;story84&#8217; branch and our remote &#8216;origin/story84&#8217; branch will be the same.  After we fetch, they will be different.  &#8216;origin/story84&#8217; will now point to one of the new commit objects we downloaded during the fetch.</p>


	<p>At this point, we may want to merge &#8216;origin/story84&#8217; into our local &#8216;story84&#8217; branch.  That&#8217;s easy enough, but if we want to do it automatically every time we fetch, we can use &#8216;git pull&#8217;, which is just a &#8216;fetch&#8217; and then a &#8216;merge&#8217; command.</p>


	<p>So, these commands are functionally equivalent:</p>


	<p>shell. $ git pull origin/story84</p>


	<p>shell. $ git fetch origin/story84; git merge origin/story84</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-fetch.html">git fetch</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-pull.html">git pull</a></li>
	</ul>


	<h3>Pushing</h3>


	<p>Now we can get updates from other repositories, but how can we push changes to them?  If we have commit rights on the repository (normally over ssh), we can simply run &#8216;git push&#8217;</p>


	<p>shell. $ git push origin master</p>


	<p>The &#8216;origin&#8217; in that case will be inferred if you leave it out, but if you&#8217;ve used a different name for your remote or you are trying to push one of your other branches, you can do that, too.</p>


	<p>shell. $ git push scott-public experimental</p>


	<p>If you don&#8217;t specify a branch, it will infer that you want to push every branch that you and the server have in common.  So, if you have pushed your &#8216;master&#8217; branch and your &#8216;experimental&#8217; branch to the &#8216;scott-public&#8217; server at any point, running this will update the server to have the newest versions of <strong>both</strong> of them:</p>


	<p>shell. $ git push scott-public</p>


	<p>Whereas this will only update the &#8216;master&#8217; branch:</p>


	<p>shell. $ git push scott-public master</p>


	<p>note.  In Git, the opposite of &#8216;push&#8217; is not &#8216;pull&#8217;, but &#8216;fetch&#8217;. A &#8216;pull&#8217; is a &#8216;fetch&#8217; and then a &#8216;merge&#8217;.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-push.html">git push</a></li>
	</ul>


	<h3>Multiple Remotes</h3>


	<p>Although a bit different in syntax maybe, most of that should seem familiar to any users of other <span class="caps">SCM</span> systems.  However, this is where the &#8216;decentralized&#8217; part comes in.  In Git, there is really no special repository.  You can add as many remote repositories that are related to your codebase in some way as you want.  You can add each of your co-workers repositories as read-only repositories, you can have a centralized one you all share, one out on your production servers outside the firewall, a public one for stable or sanitized pushes on your personal webserver, one on your build server, etc, etc.</p>


	<p>Pushing to and pulling from multiple sources is easy and straightforward. You simply add remotes :</p>


	<p>shell. $ git remote add mycap git@github.com:schacon/capistrano.git
$ git remote add official git://github.com/jamis/capistrano.git</p>


	<p>Then, if the the project is updated, I can pull in the changes from one remote, merge them locally, and then push to another remote.</p>


	<p>shell. $ git fetch official
$ git merge official/master
$ git push mycap master</p>


	<p>I can also add several remotes to pull and merge from, in this case, one for every developer with a public fork of that project that might push changes I care to try.</p>


	<p><img src="vector/Fetch_Pull.eps" alt="" /></p>


	<p>You can also remove remotes at any time, which simply removes the lines that contain the url in your &#8217;.git/config&#8217; file and the references to their remote branches in &#8217;.git/refs/[remote_name]&#8217; directory.  It will not remove any of the git objects, so if you decide to add it again and fetch, very little will be transferred.</p>


	<p>You can also view useful information about a remote branch by using the &#8216;remote show&#8217; command.  For example, if I run this on a checkout of the Git source code itself, I will see this:</p>


	<p>shell. git-remote-show.txt</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-remote.html">git remote</a></li>
	</ul>


	<h3>Possible Workflows</h3>


	<p>The idea of having multiple remote repositories that you can push to and/or pull from is probably new to you, and many people have a hard time figuring out what their workflow should look like, especially if they are moving from a centralized <span class="caps">SCM</span> system.  I will present a couple of possible workflows that I have seen, so you can determine what will work best for you and your team.</p>


	<p>Most of these are simply a matter of convention, not even configuration.  Each of the models can pretty easily change to another with minimal configuration changes &#8211; maybe some permissions tweaked here or there.</p>


	<h4>Central Repository Model</h4>


	<p>There is a single repository that all developers push to and pull from.</p>


	<p><img src="s2/workflow-star.png" alt="" /></p>


	<p>This model works just like a centralized <span class="caps">SCM</span> and Git can work that way just fine. If you setup a repository for your team on a server that everyone has ssh or <span class="caps">NFS</span> access to, Git can very easily function as a centralized repository.  This may be common on small teams with non-public projects where you don&#8217;t want to worry about a hierarchy &#8211; the strength of this model is that it forces everyone to stay up to date with each other and it doesn&#8217;t depend on a single role.</p>


	<p>Even large teams could use this, but in general there are a lot of gains to be made in larger teams with a different or hybrid model.</p>


	<h4>Dictator and Lieutenant Model</h4>


	<p>This is a highly hierarchical model where one individual has commit rights to a blessed repository that everyone else fetches from. Changes are fetched from developers by lieutenants responsible for specific subsystems and merged and tested.  Lieutenant branches are then fetched by the dictator and merged and pushed into the blessed repository, where the cycle starts over again.</p>


	<p><img src="s2/workflow-dictator.png" alt="" /></p>


	<p>This is a model something like the Linux kernel uses, Linus being the benevolent dictator. This model is much better for large teams, and can be implemented with multiple and varied levels of lieutenants and sub-lieutenants in charge of various subsystems.  At any stage in this process, patches or commits can be rejected &#8211; not merged in and sent up the chain.</p>


	<h4>Integration Manager Model</h4>


	<p>This is where each developer has a public repository, but one is considered the &#8216;official&#8217; repository &#8211; it is used to create the packages and binaries.  A person or core team has commit rights to it, but many other developers have public forks of that repository.  When they have changes, they issue a pull request to an integration manager, who adds them as a remote if they haven&#8217;t already &#8211; then merges, tests, accepts and pushes.</p>


	<p><img src="s2/integration-manager.png" alt="" /></p>


	<p>This is largely how community-based git repositories like GitHub were built to work and how many smaller open source projects operate.</p>


	<p>In the end, there is really no single &#8216;right way&#8217; to do it &#8211; being a decentralized system, you can have a model with all of these aspects to it, or any combination you can think of.  You can also have subgroups using different models on the same codebase &#8211; say your company has an internal fork of the Linux kernel that is managed by the Integration Manager model, in addition to pulling in changes occasionally from Linus&#8217;s branch.  In the end, you (or you and your team) will have to sit down for a second and think about what will work best for you.</p>


	<h2>Sharing Repositories</h2>


	<h3>Over Git</h3>


	<p>Git provides its own special protocol, which is basically just a really thin wrapper over the &#8216;git-upload-pack&#8217; command that will tell you what is available, then you tell it what you have and it gives you a packfile of the difference.  To start it up manually, run something like the following command:</p>


	<p>shell. $ git-daemon&#8212;detach&#8212;export-all&#8212;base-path=/opt/git /opt/git/ambition</p>


	<p>Though for long term running, you&#8217;ll likely want to add this to your inet.d configuration.  See the <a href="http://www.kernel.org/pub/software/scm/git/docs/git-daemon.html">git-daemon</a> docs for specific information on how to set that up.</p>


	<p>The git protocol has no built in authentication, so generally you cannot push over it (although some people have open push policies and so allow that &#8211; I would not recommend setting that up, so you&#8217;ll have to look up how to do that).  If you want your users to have push access, it&#8217;s recommended to use the ssh protocol.  Many repositories, like GitHub, have ssh enabled for account owners to push over, and git-daemon enabled for the public to pull over &#8211; which is often the most efficient combination.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-daemon.html">git-daemon</a></li>
	</ul>


	<h3>Over <span class="caps">SSH</span></h3>


	<p>Git can work entirely over <span class="caps">SSH</span> &#8211; it actually does much the same thing that happens over the git protocol, except it implicitly has authentication built in, so if the user they are ssh&#8217;ing in as has access to write to the repo, then that user can push over ssh as well.</p>


	<p>shell. $ git clone&#8212;bare; scp</p>


	<h3>Over <span class="caps">HTTP</span></h3>


	<p>this is pretty easy to setup because there is no requirement other than a static web server &#8211; it is not like <span class="caps">SVN</span> which requires a <span class="caps">DAV</span> server to run.  If you want to push over http, however, you will need <span class="caps">DAV</span> setup &#8211; it&#8217;s generally a much better idea to use ssh to do so, however.</p>


	<p>The only caveat is that you need to run &#8216;git update-server-info&#8217; each time you commit to the repository.</p>


	<p>shell. $ git update-server-info</p>


	<p>It is generally a good idea to put this in the post-commit hook file on any server that you want to be able to fetch from over <span class="caps">HTTP</span>.</p>


	<p>.sidebar actually, you can run this without update-server-info if you never pack objects and you have a pre-defined list of branches you are always fetching.  All that update-server-info does is put a list of branches into one file (.git/info/refs) and a list of pack files into another (.git/objects/info/pack) to get around the fact that you cannot reliably list contents of a directory over http &#8211; it&#8217;s not built into the protocol. So for git to know what packfiles and branches are available, it needs to have one url it can get those from.</p>


	<h2>Hosted Repositories</h2>


	<p>If you don&#8217;t want to deal with setting up and maintaining your own server for your git repository, you can use one of the growing number of public Git hosted servers.</p>


	<p>I will focus on some interesting features of a commercial service called <a href="http://github.com">GitHub</a> here, but there is also an open source project called <a href="http://gitorious.com">Gitorious</a> that has many of the same features.</p>


	<p>My focus on GitHub is only because it has private repos for commercial projects, which means you could use it to host your companies source code (as GitHub does), but also the open source ones are free, and it hosts many popular projects featured in the Peepcode series, including Ruby on Rails, Merb, RSpec, and Capistrano.</p>


	<h3>GitHub</h3>


	<p>GitHub is interesting as a source code hosting service because it includes some social networking features, which is not what most people imagine when thinking of source code hosting.</p>


	<p>You can follow your friends or developers whose work you are interested in, or individual projects.  You then subscribe to a single Atom feed and are kept up to date on what all those projects and people are doing, code-wise.</p>


	<p><img src="s2/github1.png" alt="" /></p>


	<p>More interesting, you can publicly fork a project, so you have your own copy of it.  GitHub is unique in concept in that it is really centered around individuals rather than projects.  For instance, if you want to follow or work on Merb, you would follow or fork wycats&#8217;s Merb, there is really no &#8216;official&#8217; Merb page in GitHub.  It&#8217;s simply that wycats is known to be the blessed repository by the Merb project.</p>


	<p>You could just as easily follow and fork someone else&#8217;s repository of the project.  An interesting example of this is the <a href="http://github.com/sr/git-wiki">git-wiki</a> project, which was started by a user called &#8216;sr&#8217;, then was forked and greatly modified by &#8216;al3x&#8217;.  &#8216;sr&#8217; wanted to keep the project simple, and so now there are two major versions of the project by these two.  I have a checkout of the project and remotes added for each one, so I could work on and contribute to either.</p>


	<p><img src="s2/github2.png" alt="" /></p>


	<p>Let&#8217;s say there is a popular feature request that is either not completed or not accepted by the main project maintainer.  You can very easily fork the project and keep your patch or patches up to date with the head on a regular basis and people can pull from yours instead.  Perhaps enough demand builds up or enough testing is done from all these users that the patch is accepted.  You can then delete your fork and revert to the original project head.</p>


	<p>This will also really change patch submission for large projects. Instead of emailing patches around, you can fork the project, add your patch and submit a pull request for your branch with the fix to one of the core members or through the ticketing system.  A member of the core team can add you as a remote easily, create a new testing branch, merge in or rebase your branch, test and accept or reject.  If your patch is ignored or the team doesn&#8217;t have time to deal with it yet, it&#8217;s easy to keep up to date by continually rebasing and re-sending the pull requests until it&#8217;s either rejected or accepted.  It doesn&#8217;t just go stale until it&#8217;s difficult to apply the patch anymore.</p>


	<p>Services like GitHub and an increased adoption of distributed <span class="caps">SCM</span> systems will dramatically change open source development workflows on teams of all sizes, in addition to changing the way individual developers work.</p>


	<h1>Section Three &#8211; Commands Overview</h1>


	<p>This section is meant to be a really quick reference to the commands we have reviewed in Git and a quick description of what they do, where we have talked about them and where to find out more information on them.</p>


	<h2>Basic Git</h2>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-config.html">git config</a></h3>


	<p>Sets configuration values for things like your user name, email, and gpg key, your preferred diff algorithm, file formats to use, proxies, remotes and tons of other stuff.  For a full list, see the <a href="http://www.kernel.org/pub/software/scm/git/docs/git-config.html">git-config docs</a></p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-init.html">git init</a></h3>


	<p>Initializes a git repository &#8211; creates the initial &#8217;.git&#8217; directory in a new or existing project.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-clone.html">git clone</a></h3>


	<p>Copies a Git repository from another place and adds the original location as a remote you can fetch from again and possibly push to if you have permission.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-add.html">git add</a></h3>


	<p>Adds changes in files in your working directory to your index, or staging area.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-rm.html">git rm</a></h3>


	<p>Removes files from your index and your working directory so they will stopped being tracked.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-commit.html">git commit</a></h3>


	<p>Takes all of the changes staged in the index (that have been &#8216;git add&#8217;ed),  creates a new commit object pointing to it, and advances the branch to point to that new commit.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-status.html">git status</a></h3>


	<p>Shows you the status of files in your index versus your working directory.  It will list out files that are untracked (only in your working directory), modified (tracked but not yet updated in your index), and staged (added to your index and ready for committing).</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-branch.html">git branch</a></h3>


	<p>Lists existing branches, including remote branches if &#8216;-a&#8217; is provided.  Creates a new branch if a branch name is provided.  Branches can also be created with &#8216;-b&#8217; option to &#8216;git checkout&#8217;.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-checkout.html">git checkout</a></h3>


	<p>Checks out a different branch &#8211; makes your working directory look like the tree of the commit that branch points to and updates your <span class="caps">HEAD</span> to point to this branch now, so your next commit will modify it.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-merge.html">git merge</a></h3>


	<p>Merges one or more branches into your current branch and automatically creates a new commit if there are no conflicts.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-reset.html">git reset</a></h3>


	<p>Resets your index and working directory to the state of your last commit, in the event that something screwed up and you just want to go back.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-rebase.html">git rebase</a></h3>


	<p>An alternative to merge that rewrites your commit history to move commits since you branched off to apply to the current head instead.  A bit dangerous as it discards existing commit objects.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-stash.html">git stash</a></h3>


	<p>Temporarily saves changes that you don&#8217;t want to commit immediately for later.  Can re-apply the saved changes at any time.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-tag.html">git tag</a></h3>


	<p>Tags a specific commit with a simple, human readable handle that never moves.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-fetch.html">git fetch</a></h3>


	<p>Fetches all the objects that a remote version of your repository has that you do not yet so you can merge them into yours or simply inspect them.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-pull.html">git pull</a></h3>


	<p>Runs a &#8216;git fetch&#8217; then a &#8216;git merge&#8217;.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-push.html">git push</a></h3>


	<p>Pushes all the objects that you have that a remote version does not yet have to that repository and advances its branches.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-remote.html">git remote</a></h3>


	<p>Lists all the remote versions of your repository, or can be used to add and delete them.</p>


	<h2>Inspecting Repositories</h2>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-log.html">git log</a></h3>


	<p>Shows a listing of commits on a branch or involving a specific file and optionally details about what changed between it and its parents.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-show.html">git show</a></h3>


	<p>Shows information about a git object, normally used to view commit information.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-ls-tree.html">git ls-tree</a></h3>


	<p>Shows a tree object, including the mode and name of each node and the <span class="caps">SHA1</span> value of the blob or tree that it points to. Can also be run recursively to see all subtrees as well.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-cat-file.html">git cat-file</a></h3>


	<p>Used to view the type of an object if you only have the <span class="caps">SHA1</span> value, or used to redirect contents of files or view raw information about any object.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-grep.html">git grep</a></h3>


	<p>Lets you search through your trees of content for words and phrases without having to actually check them out.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-diff.html">git diff</a></h3>


	<p>Generates patch files or statistics of differences between paths or files in your git repository, or your index or your working directory.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/gitk.html">gitk</a></h3>


	<p>Graphical Tcl/Tk based interface to a local Git repository.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-instaweb.html">git instaweb</a></h3>


	<p>Wrapper script to quickly run a web server with an interface into your repository and automatically directs a web browser to it.</p>


	<h2>Extra Tools</h2>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-archive.html">git archive</a></h3>


	<p>Creates a tar or zip file of the contents of a single tree from your repository.  Easiest way to export a snapshot of content from your repository.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-gc.html">git gc</a></h3>


	<p>Garbage collector for your repository.  Packs all your loose objects for space and speed efficiency and optionally removes unreachable objects as well.  Should be run occasionally on each of your repos.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-fsck.html">git fsck</a></h3>


	<p>Does an integrity check of the Git &#8220;filesystem&#8221;, identifying dangling pointers and corrupted objects.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-prune.html">git prune</a></h3>


	<p>Removes objects that are no longer pointed to by any object in any reachable branch.</p>


	<h3><a href="http://www.kernel.org/pub/software/scm/git/docs/git-daemon.html">git-daemon</a></h3>


	<p>Runs a simple, unauthenticated wrapper on the git-upload-pack program, used to provide efficient, anonymous and unencrypted fetch access to a Git repository.</p>


	<h1>References and Endnotes</h1>


	<p>Here are some references that I used or that you may use to find out more about Git.</p>


	<p>The example git repository that I was working with throughout this book can be cloned from its 
<a href="http://github.com/schacon/simplegit">GitHub repository</a></p>


	<p>For anything you cannot find in this book or these references, be sure to ask the fantastic people hanging out at the
&#8217;#git&#8217; channel on irc.freenode.net</p>


	<h2>Web Documentation</h2>


	<p><a href="http://www.kernel.org/pub/software/scm/git/docs/">Main Git Documentation</a>
- fantastic reference for all the command line programs</p>


	<p><a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">Git User&#8217;s Manual</a></p>


	<p><a href="http://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a>
- good detail about the <span class="caps">DAG</span> object model</p>


	<p><a href="http://www.kernel.org/pub/software/scm/git/docs/tutorial.html">A Tutorial Introduction to Git</a></p>


	<p><a href="http://wincent.com/knowledge-base/Git_rebase_explained">Git Rebase Explained</a></p>


	<p><a href="http://cworth.org/hgbook-git/tour/">A Tour of Git, the Basics</a></p>


	<p><a href="http://kerneltrap.org/node/5496">Junio Hamano New Git Maintainer</a>
- some history on git and Junio becoming the new maintainer</p>


	<h2>Screencasts</h2>


	<p><a href="http://peepcode.com/products/git">Git Peepcode Screencast</a></p>


	<p><a href="http://railscasts.com/episodes/96">RailsCasts Git Screencast</a></p>


	<p><a href="http://www.jointheconversation.org/railsgit">Using Git to Manage and Deploy Rails Apps</a></p>
