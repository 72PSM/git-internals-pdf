<h2>About this book</h2>


	<p>It took me a pretty long time to really get git. As we&#8217;ve continued to use git more and more in our company, we&#8217;ve found ourselves having to teach people what it is and why we use it over and over again, and the reality is that git generally has a pretty steep learning curve compared to some other systems. I&#8217;ve seen case after case of developers who love git after they finally understand it, but getting to that point is often somewhat painstaking.</p>


	<p>This book then is aimed at the developer who does not particularly like <span class="caps">SVN</span> or whatever <span class="caps">SCM</span> system they are currently using, has heard good things about git, but doesn&#8217;t know where to start or why it&#8217;s so wonderful. It is meant to explain git as simply and graphically as possible in a clean, concise, easily readable volume. I would like you to be able to get through this book and understand git at a fundamental level, very quickly.</p>


	<p>To accomplish this, I&#8217;m starting the book out (after the introduction) with a section about what git does, rather than how to use it. I found that I didn&#8217;t really understand git and had many problems in using it until I understood what it was doing rather than understanding it as a different, weird <span class="caps">SVN</span>-like system.</p>


	<h2>Installing Git</h2>


	<p>todo. clean up this whole section, and actually run through each of these (yes, even windows!)</p>


	<p>Before we can start playing with git, we&#8217;ll have to install it. I&#8217;ll quickly cover installing git on Linux, Mac and Windows.</p>


	<p>You can download git from http://git.or.cz/</p>


	<p>http://kernel.org/pub/software/scm/git/</p>


	<h3>Installing on Linux</h3>


	<p>wget http://kernel.org/pub/software/scm/git/git-1.5.4.4.tar.bz2
tar jxpvf git-1.5.4.4.tar.bz2
cd git-1.5.4.4
make prefix=/usr all doc info
sudo make prefix=/usr install install-doc install-info</p>


	<p>or : apt-get git-core, yum install git-core</p>


	<h3>Installing on Mac</h3>


	<p>You are likely going to want to install git without the asciidoc dependency because it is a pain to install.  When you compile from source, you will see</p>


	<h4>Mac 10.4 &#8211; Tiger</h4>


	<p>There are some requirements you&#8217;ll have to install before you can compile git.</p>


	<p>http://sourceforge.net/projects/expat/</p>


	<p>However, if you want an easier path, you can use the excellent MacPorts software:</p>


	<p>http://www.macports.org/</p>


	<p>and just run</p>


	<ol>
	<li>port install git-core</li>
	</ol>


	<h4>Mac 10.5 &#8211; Leopard</h4>


	<p>All the requirements are installed with the developer CD, so you can just download source and compile pretty easily if the developer tools are installed.</p>


	<p>MacPorts is also an easy option if you have that installed.</p>


	<p>http://code.google.com/p/git-osx-installer/</p>


	<h3>Windows</h3>


	<p>Cygwin     http://www.cygwin.com/setup.exe</p>


	<p>http://code.google.com/p/msysgit/</p>


	<p>A TortoiseCVS lookalike for Git</p>


	<p>http://repo.or.cz/w/git-cheetah.git/</p>


	<h2>A Short History of Git</h2>


	<p>Git started with Linus Torvalds scratching the very serious itch of needing a fast, efficient and massively distributed source code management system for Linux kernel development.</p>


	<p>The kernel team had moved from a patch emailing system to the proprietary BitKeeper <span class="caps">SCM</span> in 2002.  That ended in April 2005 when BitMover stopped providing a free version of it&#8217;s tool to the open source community because they felt some developers had reverse engineered it in violation of the license.</p>


	<p>Since Linus had (and still has) a passionate dislike of all existing source code management systems, he decided to write his own.  Thus, in April of 2005, Git was born.  A few months later, in July, maintenance was turned over to Junio Hamano, who has maintained the project ever since.</p>


	<p>note. &#8220;I&#8217;m an egotistical bastard, and I name all my projects after myself. First Linux, now git.&#8221; &#8211; Linus</p>


	<p>Git started out as a collection of lower level functions used in various combinations by perl scripts.  Recently (since 1.0), more and more of the perl scripts have been re-written in C, increasing portability and speed.</p>


	<p>todo. growth and adoption &#8211; list some projects (kernel, X.Org, Mesa3D, Compiz, Wine, <span class="caps">OLPC</span>, Fedora, Samba | ruby: rubinius, merb, god, github, rails?)</p>


	<p>http://git.fedoraproject.org/git/</p>


	<h1>Section 1 &#8211; Understanding Git</h1>


	<p>In this section, we will go over what git was built for and how it works, hopefully laying the groundwork to properly understand what it is doing when we run the commands.</p>


	<p>When I learned Git, as many people do, I learned it in the context of other SCMs I had used &#8211; Subversion or <span class="caps">CVS</span>.  I really think this is a horrible way to learn Git.  I felt far more comfortable with it when I stopped thinking that &#8216;git add&#8217; was sort of like &#8216;svn add&#8217;, but instead understood what it was actually doing.  Then I found I could find new and interesting ways to use what is really a very powerful and cool toolset.</p>


	<p><img src="./artwork/s1/what-git-is.png" alt="" /></p>


	<p>So, let&#8217;s see what it&#8217;s doing behind the scenes first.</p>


	<h2>What is Git?</h2>


	<p>Git is a stupid content tracker.  That is probably the best description of it &#8211; don&#8217;t think of it in a &#8216;like <span class="caps">SVN</span>, but&#8230;&#8217; context, but more like a really interesting file system.</p>


	<p>Git tracks content &#8211; files and directories.  It is at it&#8217;s heart a collection of simple tools that implement a tree history storage and directory content management system.  It is simply used as an <span class="caps">SCM</span>, not really designed as one.</p>


	<p>&#8220;In many ways you can just see git as a filesystem â€” it&#8217;s content-addressable, and it has a notion of versioning, but I really really designed it coming at the problem from the viewpoint of a filesystem person (hey, kernels is what I do), and I actually have absolutely zero interest in creating a traditional <span class="caps">SCM</span> system.&#8221; &#8211; Linus (http://marc.info/?l=linux-kernel&#38;m=111314792424707)</p>


	<p>When most SCMs store a new version of a project, they store the code delta or diff.  When Git stores a new version of a project, it stores a new tree &#8211; a bunch of blobs of content and a collection of pointers that can be expanded back out into a full directory of content and subdirectories.  If you want a diff between two versions, it doesn&#8217;t add up all the deltas, it simply looks at the two full directories and runs a new diff on them.</p>


	<p>This is what fundamentally allows the system to be easily distributed &#8211; it doesn&#8217;t have issues figuring out how to apply a complex series of deltas, it simply transfers all the directories that one user has and another does not have but is requesting.  It is efficient about it &#8211; it only stores identical files and directories once and it can compress and transfer it&#8217;s content using delta-compressed packfiles &#8211; but in concept, it is a very simple beast.  Git is at it&#8217;s heart very stupid simple.</p>


	<h3>Focus and Design</h3>


	<p>There are a number of areas that the developers of Git, including and especially Linus, have focused on in conceiving and building Git.</p>


	<h4>Non-linear Development</h4>


	<p>branching and merging</p>


	<h4>Distributed Development</h4>


	<p>local copy of the entire development history, no central repository</p>


	<h3>Efficiency</h3>


	<p>seriously faster than nearly all other <span class="caps">SCM</span> systems for most operations.</p>


	<p>todo. table of speed benchmarks for git vs. svn vs. ??
      &#8211; add, commit, push, diff, merge
      &#8211; directory/checkout sizes?</p>


	<h3>A Toolkit Design</h3>


	<p>Following the Unix tradition, Git is a collection of many small tools written in C [1]</p>


	<p>todo. expand this whole chapter</p>


	<h2>Git Object Types</h2>


	<p>There are four main object types in git, the first three being the most important to really understand the main functions of git.</p>


	<p>All of these types of objects are stored in the git object database, which is kept in the git directory [see git directory].  Each object is compressed (with Zlib) and referenced by the <span class="caps">SHA1</span> value of its contents plus a small header.  In the examples, I will use the first 6 characters of the <span class="caps">SHA</span> for simplicity, but the actual value is 40 characters long.</p>


	<p>To demonstrate these examples, we will develop a small ruby library that provides very simple bindings to git, keeping the project in a git repository.  The basic layout of the project is this:</p>


	<p><img src="./artwork/s1/layout.png" alt="" /></p>


	<p>Let&#8217;s take a look at what git does when this is committed to a repository.</p>


	<h3>The Blob</h3>


	<p><em>sidebar of git object sha algorithm (git-object-sidebar.textile)</em></p>


	<p>In git, the contents of files are stored as <strong>blobs</strong>.</p>


	<p><img src="./artwork/s1/blobs.png" alt="" /></p>


	<p>It is important to note that it is the <em>contents</em> that are stored, not the files.  The names and permissions of the files are not stored with the blob, just the contents.</p>


	<p><img src="./artwork/s1/blob-expand.png" alt="" /></p>


	<p>This means that if you have two files anywhere in your project that are exactly the same, even if they have different names, git will only store the blob once.  This also means that during repository transfers, such as clones or fetches, git will only transfer the blob once, then expand it out into multiple files upon checkout.</p>


	<h3>The Tree</h3>


	<p><em>sidebar of tree object encoding algorithm (git-tree-sidebar.textile)</em></p>


	<p>Directories in git basically correspond to <strong>trees</strong>.</p>


	<p><img src="./artwork/s1/trees.png" alt="" /></p>


	<p>A tree is a list of trees and blobs that the tree contains, along with the names and permissions of those blobs and trees.  The contents section of a tree object consists of a very simple text file that lists the <em>mode</em>, <em>type</em>, <em>name</em> and <em>sha</em> of each entry (see the sidebar for details).</p>


	<p><img src="./artwork/s1/tree-expand.png" alt="" /></p>


	<h3>The Commit</h3>


	<p>So, now that we can store arbitrary trees of content in Git, where does the &#8216;history&#8217; part of &#8216;tree history storage system&#8217; come in?  The answer is the <strong>commit</strong> object.</p>


	<p><img src="./artwork/s1/commit.png" alt="" /></p>


	<p>The commit is very simple, much like the tree.  It simply points to a tree and keeps an <em>author</em>, <em>committer</em>, <em>message</em> and any <em>parent</em> commits that directly preceded it.</p>


	<p><img src="./artwork/s1/commit-expand.png" alt="" /></p>


	<p>Since this was my first commit, there are no parents.  If I commit a second time, the commit object will look more like this:</p>


	<p><img src="./artwork/s1/commit-expand2.png" alt="" /></p>


	<p>Notice how the <em>parent</em> in that commit is the same <span class="caps">SHA1</span> value of the last commit we did?  Most times a commit will only have a single parent like that, but if you merge two branches, the next commit will point to both of them.</p>


	<p>note. the current record for number of commit parents in the Linux kernel is 12 &#8211; <em>12</em> branches merged in a single commit</p>


	<h3>The Tag</h3>


	<p>The final type of object you will find in a git database is the <strong>tag</strong>.  This is an object that provides a permanent shorthand name for a particular commit.  It contains an <em>object</em>, <em>type</em>, <em>tag</em>, <em>tagger</em> and a <em>message</em>. Normally the type is a &#8216;commit&#8217; and the object is the sha of the commit you&#8217;re tagging.  The tag can also be <span class="caps">GPG</span> signed, providing cryptographic integrity to a release or version.</p>


	<p><img src="./artwork/s1/tag-expand.png" alt="" /></p>


	<p>We&#8217;ll talk a little bit more about tags and how they differ from <em>branches</em> (which also point to commits, but are not stored as objects) in the section on [the git data model], where we&#8217;ll pull all of this together into how all these objects relate to each other conceptually.</p>


	<h2>The Git Directory</h2>


	<p>When you initialize a git repository, either by cloning an existing one or creating a new one, the first thing git does is create a &#8220;Git Directory&#8221;.  This is the directory that stores all the object data, tags, branches, hooks and more.  Everything that git permanently stores goes in this single directory.  When you clone someone else&#8217;s repository, it basically just copies the contents of this directory to your computer.  Without a checkout (called a &#8220;working directory&#8221;) this is called a &#8220;bare&#8221; git repo and moving it to another computer backs up your entire project history.  It is the soul of git.</p>


	<p>When you run &#8216;git init&#8217; to initialize your repository, the git directory is by default installed in your current working directory as &#8217;.git&#8217;.  This can be overridden with the <em><span class="caps">GIT</span>_DIR</em> environment variable at any time.  In fact, the git directory does not need to be in your source tree at all.  It&#8217;s perfectly acceptable to keep all your git directories in a central place (/opt/git/myproject.git) and just make sure to set the <span class="caps">GIT</span>_DIR variable when you switch projects you are working on (/home/username/projects/myproject).</p>


	<p>The git directory for our little project looks something like this:</p>


	<p>code. simple-git-dir-tree.txt</p>


	<p>For more in depth information on the git directory layout, see the <a href="http://www.kernel.org/pub/software/scm/git/docs/repository-layout.html">git repository layout docs.</a></p>


	<p>For now, let&#8217;s go over some of the more important contents of this directory.</p>


	<h3>.git/config</h3>


	<p>This is the main git configuration file.  It keeps your project specific git options, such as your remotes, push configurations, tracking branches and more.  Your configuration will be loaded first from this file, then from a <sub>/.gitconfig file and then from an /etc/gitconfig file, if they exist.</p>


	<p>Here is an example of what a config file might look like:</p>


	<p>code. config-example.txt</p>


	<p>See [config section] for more information on available configuration options.</p>


	<h3>.git/index</h3>


	<p>This is the default location of the &#8216;index&#8217; file for your git project.  This location can be overridden with the <em><span class="caps">GIT</span>_INDEX</em> environment variable, which is sometimes useful for temporary tree operations.  See [the index] or [advanced index operations] sections for more information on the git index.</p>


	<h3>.git/objects/</h3>


	<p>This is the main directory that holds the data of your git objects and pack files &#8211; that is, all the contents of the files you have ever checked in, plus your commit, tree and tag objects.</p>


	<p>The files are stored by their <span class="caps">SHA1</span> values.  The first two characters make up the subdirectory and the last 38 is the filename.  For example, if the <span class="caps">SHA</span> for a blob we&#8217;ve checked in was</p>


	<p>code. a576fac355dd17e39fd2671b010e36299f713b4d</p>


	<p>the file we would find the Zlib compressed contents in is</p>


	<p>code. [GIT_DIR]/objects/a5/76fac355dd17e39fd2671b010e36299f713b4d</p>


	<h3>.git/refs/</h3>


	<p>This directory normally has three subdirectories in it &#8211; <em>heads</em>, <em>remotes</em> and <em>tags</em>.  Each of these directories will hold files that correspond to your local branches, remote branches and tags, respectively.</p>


	<p>For example, if you create a &#8216;development&#8217; branch, the file .git/refs/heads/development will be created and will contain the sha of the commit that is the latest commit of that branch.</p>


	<h3>.git/HEAD</h3>


	<p>This file holds a reference to the branch you are currently on.  This basically tells git what to use as the parent of your next commit.  The contents of it will generally look like this:</p>


	<p>code. ref: refs/heads/master</p>


	<h3>.git/hooks</h3>


	<p>This directory contains shell scripts that are invoked after the git commands they are named after.  For example, after you run a commit, git will try to execute the <em>post-commit</em> script, if it has executable permissions.</p>


	<p>See [hooks section] or the 
<a href="http://www.kernel.org/pub/software/scm/git/docs/hooks.html">online hooks documentation</a>
for more information on what you can do with hooks.</p>


	<h2>The Git Data Model</h2>


	<p>In computer science speak, the Git object data store is a Directed Acyclic Graph. That is, starting at any commit you can traverse it&#8217;s parents in one direction and there is no chain that begins and ends with the same object.</p>


	<p>All commit objects point to a tree and optionally to previous commits.  All trees point to one or many blobs and/or trees.  Given this simple model, we can store and retrieve vast histories of complex trees of arbitrarily changing content quickly and efficiently.</p>


	<p>This section is meant to demonstrate how that model looks.</p>


	<h3>References</h3>


	<p>In addition to the Git objects, which are immutable &#8211; that is, they cannot ever be changed, there are references also stored in Git.  Unlike the objects, references can constantly change.  They are simple pointers to a particular commit, something like a tag, but easily moveable.</p>


	<p>Examples of references are branches and remotes.  A branch in git is nothing more than a file in the <em>.git/refs/heads/</em> directory that contains the sha of the most recent commit of that branch.  To branch that line of development, all git does is create a new file in that directory that points to the same sha.  Then, as you continue to commit, one of the branches will keep changing to point to the new commit shas, while the other one can stay where it was.</p>


	<h3>The Model</h3>


	<p>The basic data model I&#8217;ve been explaining looks something like this:</p>


	<p><img src="./artwork/s1/dag-model.png" alt="" /></p>


	<p>The cheap references I&#8217;ve represented as the grey boxes, the immutable objects are the colored round cornered boxes.</p>


	<h3>An Example</h3>


	<p>Lets look at an example of simple usage of git and which objects are stored in the git object store as we go.</p>


	<p>To begin with, we commit an initial tree of three files and two subdirectories, each directory with one file in it.  Possibly something like this:</p>


	<p>code. model-tree-example.txt</p>


	<p>When we first commit this tree, our Git model may look something like this:</p>


	<p><img src="./artwork/s1/object-dag-tree1.png" alt="" /></p>


	<p>We have 3 trees, 3 blobs, 1 commit that points to the top of the tree, the current branch pointing to our last commit and the <span class="caps">HEAD</span> file pointing to the branch we&#8217;re currently on to let Git know which commit will be the parent for the next commit.</p>


	<p>Now let&#8217;s assume that we change the <em>lib/base/base_include.rb</em> file and commit again.  At this point, a new blob is added, which changes the tree that points to it, which changes the tree that points to that tree and so on to the top of the entire directory.  Then a new commit object is added which points to it&#8217;s parent and the new tree and the branch reference is moved forward.</p>


	<p>Let&#8217;s also say at this point we tag this commit as a release, which adds a new tag object.  At this point, we&#8217;ll have the following in Git.</p>


	<p><img src="./artwork/s1/object-dag-tree2.png" alt="" /></p>


	<p>Notice how the other two blobs that were not changed were not added again.  The new trees that were added point to the same blobs in the data store that the previous trees pointed to.</p>


	<p>Now let&#8217;s say we modify the <em>init.rb</em> file at the base of the project.  The new blob will have to be added, which will add a new top tree, but all the subtrees will not be modified, so Git will re-use those references.  Again, the branch reference will move forward and the new commit will point to it&#8217;s parent.</p>


	<p><img src="./artwork/s1/object-dag-tree3.png" alt="" /></p>


	<p>At this point, let&#8217;s stop to look at the objects we now have in our repository.  From this, we can easily recreate any of the three directories we committed by following the graph from the commit object.</p>


	<p>For instance, if we wanted the first tree, we could look for the parent of the parent of the <span class="caps">HEAD</span>, or the parent of the tag.  If we wanted the second tree, we could ask for the commit pointed to by the tag, and so on.</p>


	<p><img src="./artwork/s1/object-dag.png" alt="" /></p>


	<p>So, to keep all the information and history on the three versions of this tree, git stores 16 immutable, signed, compressed objects.</p>


	<h3>Traversal</h3>


	<p>So, what do all the arrows in these illustrations really mean?  How does Git actually retrieve these objects in practice?  Well, it gets the initial <span class="caps">SHA</span> of the starting commit object by looking in the <em>.git/refs</em> directory for the branch, tag or remote you specify.  Then it traverses the objects by walking the trees one by one, checking out the blobs under the names listed.</p>


	<p><img src="./artwork/s1/traversing-git-objects.png" alt="" /></p>


	<h2>Branching and Merging</h2>


	<p>Here we come to one of the real strengths of Git, cheap branching.  This is a feature that truly sets it apart and will likely change the way you think about developing code once you get used to it.</p>


	<p>When you are working on code in git, storing trees in any state and keeping pointers to them is very simple, as we&#8217;ve seen.  In fact, in Git the act of creating a new branch is simply writing a file in the &#8217;.git/refs/heads&#8217; directory that has the sha of the last commit for that branch.</p>


	<p>.note Branching is just writing 40 characters to a file</p>


	<p>Switching to that branch simply means making your working directory look like the tree that sha points to and updating the <span class="caps">HEAD</span> file so each commit from that point on moves that branch pointer forward (makes the 40 characters in &#8217;.git/refs/heads/[current_branch_name]&#8217; be the <span class="caps">SHA</span> of your last commit).</p>


	<p>Merging is also simple, compared to most <span class="caps">SCM</span> systems &#8211; is just merging the trees that the commits you are trying to merge are pointing to, which is much simpler than resolving a bunch of deltas.</p>


	<p>Now, let&#8217;s see how git handles branching, fetching and merging operations abstractly. For the following illustrations, we will represent the entire tree and the commit it points to as a single object.</p>


	<p><img src="./artwork/s1/branches1.png" alt="" /></p>


	<h3>Simple Case</h3>


	<p>Let&#8217;s say we work on a project for a while, then we get an idea for something that may not work out, but we want to do a quick proof-of-concept.  We create a new branch called &#8216;experiment&#8217; off of our main branch, which is by convention called &#8216;master&#8217;.  We then switch to the new branch, then create a few commits.</p>


	<p><img src="./artwork/s1/branch-story1.png" alt="" /></p>


	<p>Then, our boss comes in and says we need a hot fix to production.  So we switch back to our master branch, make the change, push the release and then tag the commit with the release number. Then we go back to our &#8216;experiment&#8217; branch, continue working and commit again.</p>


	<p><img src="./artwork/s1/branch-story2.png" alt="" /></p>


	<p>At this point, we show the new branch to our co-workers and everyone likes the new changes. We decide we want to merge them back into our main branch, so we merge the changes and delete our &#8216;experiment&#8217; branch.</p>


	<p><img src="./artwork/s1/branch-story3.png" alt="" /></p>


	<h3>Remotes</h3>


	<p>Now lets take a look at remotes.  Remotes are basically other peoples branches of the same repository.  If you got your repository by cloning it, rather than initializing it, you should have a remote branch of where you copied it from automatically added as &#8216;origin&#8217; by default.  Which means the tree that was checked out during your initial clone would be referenced as &#8216;origin/master&#8217;, which means &#8216;the master branch of the origin remote&#8217;.</p>


	<p>Lets say you clone someone&#8217;s repository and make a few changes.  You would have two references, one to &#8216;origin/master&#8217; which points to where the master branch was on the persons repository you cloned from when you did so, and a &#8216;master&#8217; branch that points the most recent local commit.</p>


	<p><img src="./artwork/s1/remote-story1.png" alt="" /></p>


	<p>Now lets say you run a <em>fetch</em>. A fetch pulls all the refs and objects that you don&#8217;t already have from the remote repository you specify.  By default, it is origin, but you can name your remotes anything, and you can have more than one.  Lets say we fetch from the repository that we originally cloned from and they had been doing some work.  They have now committed a few times on their master branch, but they also branched off at one point to try an idea, and they named the branch &#8216;idea&#8217; locally.  We now have access to those changes as &#8216;origin/idea&#8217;.</p>


	<p><img src="./artwork/s1/remote-story2.png" alt="" /></p>


	<p>We look at the &#8216;idea&#8217; branch and like where they&#8217;re going with it, but we also want the changes they&#8217;ve made on their master branch, so we do a 3-way merge of their two branches and our master.  We don&#8217;t know how well this is going to work, so we make a &#8216;tryidea&#8217; branch first and then do the merge there.</p>


	<p><img src="./artwork/s1/remote-story3.png" alt="" /></p>


	<p>Now we can run our tests and merge back into our master branch if we want.  Then we can tell our friend we cloned from to fetch from our repository, where we&#8217;ve merged their two branches for them and integrated some of our changes as well.  They can choose to accept or reject that &#8220;patch&#8221;.</p>


	<h3>Rebasing</h3>


	<p>Let&#8217;s say you and another developer, Jen, are working on the same project simultaneously.  She clones from you, and works for a while and commits.  You have committed in the meantime and want to get your work in sync, so you add her repository as the remote &#8216;jen&#8217;, do a fetch and merge her changes in, creating a new merge commit.  (All commits that are simply merges are given a darker color in this example)</p>


	<p><img src="./artwork/s1/rebase1.png" alt="" /></p>


	<p>At this point, you both do work and commit changes and then you fetch and merge from her again.  Then she does another commit and you fetch and merge once more.  At this point, you&#8217;ll have a commit history that looks something like this:</p>


	<p><img src="./artwork/s1/rebase2.png" alt="" /></p>


	<p>Perfectly fine, but it can get a little confusing when you litter the history with all those commits that do nothing but merge unshared changes.  The longer you keep out of sync, the worse this can get.</p>


	<p>This is where the rebasing command comes in.  With rebase, git will checkout the <em>upstream branch</em>, in this case, Jen&#8217;s master branch, and then replay all the changes you&#8217;ve done since you forked on top of those file, as if you had forked your work off at that point and done all your changes, rather than earlier.</p>


	<p>Rebase will literally produce a series of patch files of your work and start applying them to the upstream branch, automatically making new commits with the same messages as before and orphaning your older ones.  Git will automatically remove these eventually, since nothing points to them, when you run the garbage collector (see git-gc).</p>


	<p>So let&#8217;s see what happens if we rebase rather than merge in the same scenario.  Here we have our first merge and we can see that it orphans <em>Commit 1</em> and applies the changes between <em>Commit 0</em> and <em>Commit 1</em> to the files in <em>Remote Commit 1</em>, creating a new <em>Commit 2</em>.</p>


	<p><img src="./artwork/s1/rebase3.png" alt="" /></p>


	<p>Then, as you&#8217;ll remember, you and Jen both commit again.  You&#8217;ll notice that now it looks like she cloned you and committed and then you changed that code, rather than you both working at the same time and merging.</p>


	<p><img src="./artwork/s1/rebase4.png" alt="" /></p>


	<p>At this point, instead of merging two more times like we did originally, we rebase the next two commits she makes.</p>


	<p><img src="./artwork/s1/rebase5.png" alt="" /></p>


	<p><img src="./artwork/s1/rebase6.png" alt="" /></p>


	<p>And finally, we are left with a commit history that looks like Figure 1, rather than Figure 2, which is what we would have if we had merged instead.</p>


	<p><img src="./artwork/s1/rebase7-final.png" alt="" /></p>


	<p>note. You should remember to only do this on local branches before you push or on repositories that nobody has fetch access to &#8211; if anyone pulls down the objects that will become abandoned during a rebase, it gets a bit frustrating.</p>


	<h3>Use Cases</h3>


	<p>So why is this helpful, exactly?  It means that you can keep your development cycles loosely coupled.  Here is an example of a common workflow with cheap branches.</p>


	<p>You have a &#8216;master&#8217; branch that is <em>always</em> stable &#8211; you never merge anything into it that you wouldn&#8217;t put into production. Then you have a &#8216;development&#8217; branch that you merge any experimental code into before you imagine pulling it into the &#8216;master&#8217; branch.</p>


	<p>You create a new branch each time you begin to work on a story or feature, branching it off your current &#8216;development&#8217; branch each time, so if you get blocked and need to put it on hold, it doesn&#8217;t effect anything else.  When you do get back to them, you rebase them to the current &#8216;development&#8217; and it&#8217;s just like you started from there.  Often times you merge the branch back into &#8216;development&#8217; and delete it the same day that you created it.</p>


	<p>If you get a huge project or idea &#8211; say refactoring the entire code base to the newest version of your framework or switching database vendors or something, you create a long-term branch, continuously rebase it to keep it in line with other development, and once everything is tested and ready, merge it in with your master.</p>


	<p>Working with others is unbelievably easy. You ask in an <span class="caps">IRC</span> room if someone has implemented a feature in a library you are using.  Turns out that someone has and you are sent the <span class="caps">URL</span> of their public git repo for that project.  You add it as a remote, fetch it, create a new &#8216;merge-feature&#8217; branch off your &#8216;development&#8217; branch, merge in the new changes and you&#8217;re done.  No emailing patches around and applying them &#8211; just add contributors as a remote and try out their branches before deciding to merge them in. If it breaks things or is not a good patch, you simply delete the &#8216;merge-feature&#8217; branch and that&#8217;s it.</p>


	<p>You branch and rebase or merge several times a day in and out of several different branches, some of which last for hours and some are continually there.  Once you get used to this pattern, it completely changes the way you approach your development and the way you contribute and collaborate.</p>


	<h2>The Treeish</h2>


	<p>Besides branch heads, there are a number of shorthand ways to refer to particular objects in the Git data store.  These are often referred to as a <em>treeish</em>.  Any Git command that takes an object &#8211; be it a commit, tree or blob &#8211; as an argument can take one of these shorthand versions as well.</p>


	<p>I will list here the most common, but please read the 
<a href="http://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html">rev-parse command</a>
for full descriptions of all the available syntaxes.</p>


	<h4>Full <span class="caps">SHA</span></h4>


	<p>code. dae86e1950b1277e545cee180551750029cfe735</p>


	<p>You can always list out the entire <span class="caps">SHA1</span> value of the object to reference it.  This is sometimes easy if you&#8217;re copying and pasting values from a tree listing or some other command.</p>


	<h4>Partial <span class="caps">SHA</span></h4>


	<p>code. dae86e</p>


	<p>Just about anything you can reference with the full <span class="caps">SHA</span> can be referenced fine with the first 6 or 7 characters.  Even though the <span class="caps">SHA</span> is always 40 characters long, it&#8217;s very uncommon for more than the first few to actually be the same.  Git is smart enough to figure out a partial <span class="caps">SHA</span> as long as it&#8217;s unique.</p>


	<h4>Branch or Tag Name</h4>


	<p>code. master</p>


	<p>Anything in <em>.git/refs/heads</em> or <em>.git/refs/tags</em> can be used to refer to the commit it points to.</p>


	<h4>Date Spec</h4>


	<p>code. master@{yesterday}
 master@{1 month ago}</p>


	<p>This example would refer to the value of that branch yesterday.  Git will go through the commit parents until it found one that matched that date.</p>


	<h4>Ordinal Spec</h4>


	<p>code. master@{5}</p>


	<p>This indicates the 5th prior value of the master branch.  Like the <em>Date Spec</em>, this depends on special files in the <em>.git/log</em> directory that are written during commits.</p>


	<h4>Carrot Parent</h4>


	<p>code. e65s46<sup>2
 master</sup>2</p>


	<p>This refers to the Nth parent of that commit.  This is only really helpful for commits that merged two or more commits &#8211; it is how you can refer to a commit other than the first parent.</p>


	<h4>Tilde Spec</h4>


	<p>code. e65s46</sub>5</p>


	<p>The tilde character, followed by a number, refers to the Nth generation grandparent of that commit.  To clarify from the carrot, this is the equivalent commit in carrot syntax:</p>


	<p>code. e65s46<sup>^^</sup><sup></p>


	<p><img src="./artwork/s1/treeish.png" alt="" /></p>


	<h4>Tree Pointer</h4>


	<p>code. e65s46</sup>{tree}</p>


	<p>This points to the tree of that commit.  Any time you add a ^{tree} to any commit-ish, it resolves to it&#8217;s tree.</p>


	<h4>Blob Spec</h4>


	<p>code. master:/path/to/file</p>


	<p>This is very helpful for referring to a blob under a particular commit or tree.</p>


	<h2>Working Directory</h2>


	<p>The working directory is the checkout of the current branch you are working on.  What is really important to note here is that this code is a working copy &#8211; it is not really important.</p>


	<p>This is something that developers from the Subversion world have a hard time understanding and tends to scare them mightily.  If you check out a different branch, git will basically make your working directory look like that branch, removing any checked in content that is currently in your working directory that is not in the new tree.</p>


	<p>note. the files in your working directory are temporary, they are not your repository!</p>


	<p>Most long time Subversion users don&#8217;t like to see content automatically removed from their directories, but that&#8217;s one of the mental shifts you&#8217;ll need to make.  Your working directory is temporary &#8211; everything is stored permanently in your git repository.  Your working directory is just a copy of a tree so you can edit it and commit changes.</p>


	<h2>The Index</h2>


	<p>The index was called the cache for a while, because that&#8217;s largely what it does.  It is a staging area for changes that are made to files or trees that are not committed to your repository yet.  It is also used to speed up some operations.  It acts as sort of a middle ground between your working directory and your repository.</p>


	<ul>
	<li>keeping track of the state of working directory files</li>
		<li>staging changes</li>
		<li>generating commits</li>
	</ul>


	<h2>Non-SCM Uses of Git</h2>


	<p>I keep saying that Git is primarily a content tracking system with an <span class="caps">SCM</span> tools built on top of it.  So, if it&#8217;s not built specifically to be an <span class="caps">SCM</span>, perhaps it would be useful to see some other examples of things it might be good for.</p>


	<p>(uses for slowly changing distributed trees)</p>


	<h3>Peer to Peer Content Distribution Network</h3>


	<p>Imagine you have a network of &#8230;</p>


	<p>http://gittorrent.utsl.gen.nz/rfc.html</p>


	<h3>Distributed Document Oriented Database</h3>


	<p>replication, search w/grep, no history loss</p>


	<h4>Distributed Wiki</h4>


	<p>(offline writing)
Branches, merges &#8211; distributed, adhoc documentation, book writing
(git-wiki)</p>


	<h4>Distributed Issue Tracker</h4>


	<p>(offline working on tickets)
(http://www.distract.wellquite.org/ Monotone)
(http://bugseverywhere.org/be/show/HomePage)</p>


	<h3>Backup Tool</h3>


	<p>Let&#8217;s say you want to build something like a distributed Time-Machine (Apple all rights reserved).</p>


	<p>(http://eigenclass.org/hiki/gibak-backup-system-introduction)</p>


	<h1>Section 2 &#8211; Using Git</h1>


	<p>Now that you understand what Git does at a fundamental level &#8211; how it tracks and stores content, how it stores branches and merges and tracks remote copies of the repository, let&#8217;s see how to actually use it.  This next section presents some of the basic commands that you will need to know in order to use git effectively.</p>


	<p>At the end of each section, there will be a link to the full documentation for each of the commands used in that section, in case you want to learn more or see all the options for that command.</p>


	<h2>Getting a Git Repository</h2>


	<p>There are two major ways you will get a Git repository &#8211; you will either clone an existing project, or you will initialize a new one.</p>


	<h3>New Repositories</h3>


	<p>To create a new Git repository somewhere, simply go to the directory you want to add to version control and type</p>


	<p>shell. git init</p>


	<p>This will create a <em>.git</em> directory in your current working directory that is entirely empty.  If you have existing files you want to add to your new repository, type</p>


	<p>shell. git add .
git commit -m &#8216;my first commit&#8217;</p>


	<p>This will add all of your current files into your new repository and index and then create your first commit object, pointing your new &#8216;master&#8217; branch to it.  Congratulations, you have now added your source code to Git.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-init.html">git init</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-commit.html">git commit</a> </li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-add.html">git add</a></li>
	</ul>


	<h3>Cloning a Repository</h3>


	<p>Many times you will be cloning a repository, however.  This means that you are creating a complete copy of another repo, including all of it&#8217;s history and published branches.</p>


	<p>In order to do this, you simply need a <span class="caps">URL</span> that has a git repository hosted there, which can be over <em>http</em>, <em>https</em>, <em>ssh</em> or the special <em>git</em> protocol. We will use the public hosted repository of the simple library I mentioned at the beginning of the book.</p>


	<p>shell. git clone git://github.com/schacon/simplegit.git</p>


	<p>This will by default create a new directory called &#8216;simplegit&#8217; and do an initial checkout of the &#8216;master&#8217; branch.  If you want to put it in a different directory, you can specify that on the command line, too.</p>


	<p>shell. git clone git://github.com/schacon/simplegit.git my_directory</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-clone.html">git clone</a></li>
	</ul>


	<h2>Normal Workflow Examples</h2>


	<p>Now that we have our repository, let&#8217;s go through some normal workflow examples of a single person developing.</p>


	<h3>Ignoring</h3>


	<p>First off, we will often want Git to automatically ignore certain files &#8211; often ones that are automatically generated during our development.  For example, in Rails development we often want to ignore the log files, the production specific configuration files, etc. To do this, we can add patterns into the <em>.gitignore</em> file to tell Git that we don&#8217;t want it to track them.</p>


	<p>Here is an example <em>.gitignore</em> file.</p>


	<p>code. gitignore.txt</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/gitignore.html">.gitignore</a></li>
	</ul>


	<h3>Adding and Committing</h3>


	<p>Now we&#8217;ll do some development and periodically commit our changes.  We have a few options here &#8211; we can commit individual files or we can tell the <em>commit</em> command to automatically add all modified files in our working directory to the index, then commit it.</p>


	<p>A good way to find out what you&#8217;re about to commit (that is, what is in your index) is to use the &#8216;status&#8217; command.</p>


	<p>shell. git-status.txt</p>


	<p>In this example, I can see that I&#8217;ve modified three files in my working directory, but none of them have been added to the index yet &#8211; they are not staged and ready to be committed.  If I want to make these changes in two separate commits, or I have completed work on some of them and would like to push that out, I can specify which files to add individually and then commit.</p>


	<p>shell. git-add-status.txt</p>


	<p>You can see that if we commit at this point, only the Rakefile will show up as changed in the commit.</p>


	<p><img src="./artwork/s2/git-add-commit.png" alt="" /></p>


	<p>If we want to commit all our changes, we can use this shorthand, which will automatically run a &#8216;git add&#8217; on every modified file to our index, then commit the whole thing:</p>


	<p>shell. $&gt; git commit -a -m &#8216;committing all changes&#8217;</p>


	<p><img src="./artwork/s2/git-commit-a.png" alt="" /></p>


	<p>If you would like to give a more useful commit message, you can leave out the &#8216;-m&#8217; option.  That will fire up your $EDITOR to add your commit message.</p>


	<p>note. Give special care to the first line of your commit message &#8211; it will often be the only thing people see when they are looking through your commit history.</p>


	<p>Now we can continue this loop &#8211; modifying, adding and committing &#8211; during our development.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-status.html">git status</a></li>
	</ul>


	<h3>Interactive Adding</h3>


	<p>Although that will work for all of your development needs &#8211; many developers simply use &#8216;-a&#8217; nearly every time they commit to just automatically add everything to the index, there is another way of adding files that makes for a more controlled and thematic set of commits.  This is called &#8216;interactive&#8217; adding, and it is a very powerful tool to controlling what goes into each commit.</p>


	<p>Let&#8217;s say we add a new function to our &#8216;lib/simplegit.rb&#8217; file, add a new task to our &#8216;Rakefile&#8217; and then add a new &#8216;TODO&#8217; file to our project.  Later we come back and want to commit, but we don&#8217;t remember which files had to do with each other and we don&#8217;t just want to commit them all together because that&#8217;s confusing for collaborators trying to review our code. &#8216;Interactive&#8217; mode let&#8217;s us modify our index interactively before committing.  To fire it up, type &#8216;git add -i&#8217;:</p>


	<p>.shell s2/interactive-mode1.txt</p>


	<p>We can see that we have two files that are being tracked (have been added at some point in the past) that have been modified.  We cannot yet see our new <span class="caps">TODO</span> file, though.  To add that, type &#8216;4&#8217; for the &#8216;add untracked&#8217; option and hit enter.</p>


	<p>.shell s2/interactive-mode2.txt</p>


	<p>You will see all the untracked files in your working directory.  Type the numbers of the files you want to add and hit enter twice when you&#8217;re done. This will drop you back to the main menu.  You can then type &#8216;1&#8217; to see what your index looks like now.</p>


	<p>.shell s2/interactive-mode3.txt</p>


	<p>You can see that the <span class="caps">TODO</span> file is now staged (in the index), but the other two are not.  Let&#8217;s add the Rakefile, but not the &#8216;lib/simplegit.rb&#8217; file and commit it. To do that, we hit &#8216;2&#8217;, which lists the files we can update, type &#8216;1&#8217; and enter to add the Rakefile, then hit enter again to go back to the main menu.  Then we hit &#8216;7&#8217; to exit and run the &#8216;git commit&#8217; command</p>


	<p>.shell s2/interactive-mode4.txt</p>


	<p>The interactive shell is pretty simple &#8211; playing with it instead of running &#8216;git add&#8217; commands directly may help in understanding what&#8217;s happening, since you can see the status of your files in the index versus the working directory more clearly.  It helps visualize that what is in your index (the &#8216;staged&#8217; column) is what will be committed when you run &#8216;git commit&#8217;</p>


	<h2>Log &#8211; the Commit History</h2>


	<p>So, now we have all this history in our Git repository.  So what?  What can we do with it?  How can we see this history?</p>


	<p>The answer is the very powerful <em>git log</em> command.  The &#8216;log&#8217; command will show you nearly anything you want to know about your commit history.  Also, since the entire history is stored locally, it&#8217;s really fast compared with most other <span class="caps">SCM</span> systems.</p>


	<p>If you just run <em>git log</em>, you will get output like this:</p>


	<p>shell. git-log.txt</p>


	<p>This will show you the sha of each commit, the committer and date of the commit, and the full message, starting from the last commit on your current branch and going backward in reverse chronological order (so if there are multiple parents, it just orders them by date)</p>


	<h3>Formatting Log Output</h3>


	<p>This all takes up a lot of space though, so there are ways to limit and format this output differently.  &#8216;&#8212;pretty&#8217; is a useful option for formatting the output in different ways. 
For example, we can list the commit shas and the first line of the message with &#8216;&#8212;pretty=oneline&#8217;:</p>


	<p>shell. git-log-oneline.txt</p>


	<p>With &#8216;&#8212;pretty&#8217;, you can choose between oneline, short, medium, full, fuller, email, raw and format:<string>, where <string> is a format you specify with variables.</p>


	<h3>Filtering Log Output</h3>


	<p>There are also a number of options for filtering the log output.  You can specify the maximum number of commits you want to see with &#8216;-n&#8217;, you can limit the range of dates you want to see commits for with&#8212;since and&#8212;until, you can filter it on the author or committer, text in the commit message and more.  Here is an example showing the last 30 commits between yesterday and a month ago by me with &#8216;controller&#8217; in the message:</p>


	<p>shell. git log -n 30&#8212;since=&#8221;1 month ago&#8221;&#8212;until=yesterday&#8212;author=&#8221;schacon&#8221;</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-log.html">git log</a></li>
	</ul>


	<h2>Browsing Git</h2>


	<p>Git also gives you access to a number of lower level tools that can be used to browse the repository, inspect the status and contents of any of the objects, and are generally helpful for inspection and debugging.</p>


	<h3>Showing Objects</h3>


	<p>The &#8216;git show&#8217; command is really useful for presenting any of the objects in a very human readable format.  Running this command on a file will simply output the contents of the file.  Running it on a tree will just give you the filenames of the contents of that tree, but none of it&#8217;s subtrees.  Where it&#8217;s most useful is using it to look at commits.</p>


	<h4>Showing Commits</h4>


	<p>If you call it on a tree-ish that is a commit object, you will get simple information about the commit (the author, message, date, etc) and a diff of what changed between that commit and it&#8217;s parents.</p>


	<p>.shell git-show-commit.txt</p>


	<h4>Showing Trees</h4>


	<p>Instead of the &#8216;git show&#8217; command, it&#8217;s generally more useful to use the lower level &#8216;git ls-tree&#8217; command to view trees, because it gives you the shas of all the blobs and trees that it points to.</p>


	<p>.shell git-lstree1.txt</p>


	<p>You can also run this command recursively, so you can see all the subtrees as well.  This is a great way to get the sha of any blob anywhere in the tree without having to walk it one node at a time.</p>


	<p>.shell git-lstree2.txt</p>


	<p>The &#8216;-t&#8217; makes it also show the shas of the subtrees themselves, rather than just all the blobs.</p>


	<h4>Showing Blobs</h4>


	<p>Lastly, you may want to extract the contents of individual blobs.  The &#8216;cat-file&#8217; command is an easy way to do that, and can also serve to let you know what type of object a sha is, if you happen to not know.  It is sort of a catch-all command that you can use to inspect objects.</p>


	<p>.shell git-catfile.txt</p>


	<p>With those basic commands, you should be able to explore and inspect any object in any git repository relatively easily.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-show.html">git show</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-ls-tree.html">git ls-tree</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-cat-fileÃŸ.html">git cat-file</a></li>
	</ul>


	<h2>Git Diff</h2>


	<p>Git has a great diff utility built in that can give you statistics or a patch file given any combination of tree objects, working directory and index.</p>


	<p>Two common uses of this include seeing what you&#8217;ve worked on but not committed yet, and creating a patch file to send to someone over email (though there is a much preferred way to do that which we will learn about in the &#8220;distributed workflow&#8221; section a bit later).</p>


	<h3>What has changed?</h3>


	<p>If you simply run &#8216;git diff&#8217; with no arguments, it will show you the differences between your current working directory and my index, that is, the last time I ran &#8216;git add&#8217; on my files.  For example, if I add my email to the <span class="caps">README</span> file and run it, I will see this:</p>


	<p>.shell git-diff-readme.txt</p>


	<p>You can also use &#8216;git diff&#8217; to show you some spiffy stats for a diff, rather than a patch file, if you want to see a wider overview of what changed, then drill down into specific files later.  Here are some examples getting stats, the first for the differences between two commits and the second a summary between a commit and the current <span class="caps">HEAD</span>.</p>


	<p>.shell git-diff-stat.txt</p>


	<p>If you want to see what the specific difference is in one of those files, you can just add a path limiter to the diff command.</p>


	<p>.shell git-diff-file.txt</p>


	<p>You can use this command to detect changes between your index and any tree, or your working directory and any tree, your working directory and your index, etc.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-diff.html">git diff</a></li>
	</ul>


	<h2>Branching</h2>


	<p>This is the fun part of Git that you&#8217;ll come to love like a child. When you first initialize a git repository, or clone one, you&#8217;ll get a &#8216;master&#8217; branch by default if you don&#8217;t specify something else.  This is really just a git suggestion and you don&#8217;t have to use it &#8211; like just about everything in Git, it can be overridden.</p>


	<h3>Switching Branches</h3>


	<p>However, let&#8217;s say we&#8217;re working on our project and we want to add a new function to our library, so we&#8217;ll make a new branch called &#8216;newfunc&#8217; and switch to it.  There are two ways we can do this, one is to create the branch and then switch to it:</p>


	<p>.shell $&gt;git branch newfunc; git checkout newfunc</p>


	<p>The other way is to checkout a branch that doesn&#8217;t exist yet and tell git you want to create it by passing the &#8216;-b&#8217; flag:</p>


	<p>.shell $&gt; git checkout -b newfunc</p>


	<p>Now, to check which branch we are on, we just type &#8216;git branch&#8217;:</p>


	<p>.shell git-branch.txt</p>


	<p>We can see we are now on our new branch.  This means that if we modify a file and commit it, this branch will include that change, but the &#8216;master&#8217; branch will not have it yet.  So, we add a new method to our library and commit it.</p>


	<p>.shell $&gt; vim lib/simplegit.rb; git commit -a -m &#8216;added lstree function&#8217;
Created commit 1a8c32e: added lstree function
 1 files changed, 4 insertions(+), 0 deletions(-)</p>


	<p>Now we want to change something in the <span class="caps">README</span> in the &#8216;master&#8217; branch, but we haven&#8217;t tested this function yet so we don&#8217;t want to merge our new branch in yet.  That&#8217;s fine, we just switch back and make the change.</p>


	<p>.shell git-checkout-master-work.txt</p>


	<p>Now lets see what the differences in our branches are.</p>


	<p>.shell git-branch-diff.txt</p>


	<p>We could also get a patch file for one to apply to the other, but what we really want to do next is merge the two.</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-branch.html">git branch</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-checkout.html">git checkout</a></li>
	</ul>


	<h2>Simple Merging</h2>


	<p>So now we want to move the changes in our &#8216;newfunc&#8217; branch back into our &#8216;master&#8217; branch and remove it.  This will require us merging one branch into another.  Since we&#8217;re already in our &#8216;master&#8217; branch, we&#8217;ll merge in the &#8216;newfunc&#8217; branch like this:</p>


	<p>.shell $&gt;git merge newfunc</p>


	<p>Easy peasy.  We can see that the simplegit.rb file now has 4 new lines and the <span class="caps">README</span> file was auto-merged.</p>


	<p>Now we can get rid of our &#8216;newfunc&#8217; branch with a simple:</p>


	<p>.shell $&gt;git branch -d newfunc
Deleted branch newfunc.</p>


	<h3>Resolving Conflicts</h3>


	<p>That was a fairly simple problem, but what if we branch our code and then edit the same place in a file in two different ways?  In that case, we&#8217;ll get a conflict when we try to merge them back together.  Git is not too aggressive in trying to resolve conflicts, since you don&#8217;t want it to make assumptions that are not necessarily correct, so bugs aren&#8217;t introduced without your knowledge.</p>


	<p>Let&#8217;s say that we created a &#8216;versioning&#8217; branch and then modified the version in the Rakefile to different versions in both the new branch and the &#8216;master&#8217; branch, then tried to merge them together.</p>


	<p>.shell s2/merge-conflict.txt</p>


	<p>It tells us that there was a conflict and so the new commit object was not created.  We will have to merge the conflicted file manually and then commit it again.  The output tells us the files that had conflicts, in this case it was the Rakefile.</p>


	<p>.ruby s2/rakefile.rb</p>


	<p>We can see that in the &#8216;master&#8217; branch, the version was changed to &#8216;0.1.2&#8217; and in the &#8216;versioning&#8217; branch, the same line was changed to &#8216;0.2.0&#8217;.  All we have to do is choose which one is correct and remove the rest of the lines, like so:</p>


	<p>.ruby s2/rakefile-post.rb</p>


	<p>Now we add and commit that file, and we&#8217;re good.</p>


	<p>.shell $&gt;git add Rakefile 
$&gt;git commit -m &#8216;fixed conflict&#8217;
Created commit 47c668a: fixed conflict</p>


	<ul>
	<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-branch.html">git branch</a></li>
		<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-merge.html">git merge</a></li>
	</ul>


	<h2>Rebasing</h2>


	<h3>Interactive Rebasing</h3>


	<h3>Resetting Your Branch</h3>


	<p>reset</p>


	<h2>Distributed Workflow Examples</h2>


	<h3>Cloning</h3>


	<h3>Fetching, Pulling (tracking branches)</h3>


	<h3>Pushing</h3>


	<h3>Formatting Patches</h3>


	<h2>All About Remotes (refspec)</h2>


	<h2>Tagging</h2>


	<h2>Sharing Repositories</h2>


	<h3>Over <span class="caps">SSH</span></h3>


	<p>git clone&#8212;bare; scp</p>


	<h3>Over Git</h3>


	<p>git daemon&#8212;detach</p>


	<h3>Over Http</h3>


	<p>git update-server-info</p>


	<h4>GitHub</h4>


	<h1>Section 3 &#8211; Git and Other Systems</h1>


	<h2>Git and <span class="caps">SVN</span></h2>


	<h3>Pros and Cons</h3>


	<h3>Importing existing <span class="caps">SVN</span> projects</h3>


	<h3>git-svn</h3>


	<h3>git-svn-server</h3>


	<h3>Piston / <span class="caps">SVN</span> Externals</h3>


	<h2>Git and Ruby</h2>


	<h3>Ruby/Git</h3>


	<h3>Grit</h3>


	<h3>Git-Ruby</h3>


	<h2>Git and Application Deployment</h2>


	<h3>Capistrano Module</h3>


	<h3>Vlad the Deployer Module</h3>


	<h1>Advanced Git</h1>


	<h2>Bisect</h2>


	<h2>Reading and Writing Trees</h2>


	<h2>Advanced Index Operations</h2>


	<h2>File and Index Staging</h2>


	<h2>Submodules</h2>


	<h2>Advanced Merging</h2>


	<ul>
	<li>merge strategies
	<ul>
	<li>resolve</li>
		<li>recursive</li>
		<li>octopus</li>
	</ul></li>
	</ul>


	<p>rebase&#8212;interactive</p>


	<h2>Shared Repositories</h2>


	<h2>Hooks</h2>


	<h2>Configuration Options</h2>


	<h2>History Manipulation</h2>


	<h3>Git Filter Branch</h3>


	<p>http://www.kernel.org/pub/software/scm/git/docs/git-filter-branch.html</p>


	<h3>Splitting One Commit into Two</h3>


	<h2>Repository Maintenance</h2>


	<h2>Patch Management</h2>


	<h2>Recovering From Corruption</h2>


	<p>(creating a branch from an abandoned commit)
git branch recovered-branch 7281251ddd</p>


	<h1>Commands Overview</h1>


	<h2>The Plumbing</h2>


	<h2>The Porcelain</h2>


	<h1>The Appendix</h1>


	<p>There are some things about Git that took me a while to learn, mostly during my time trying to re-implement a lot of the internals for my pure-ruby version of Git (http://github.com/schacon/git-ruby).  Since most of these are pretty hard to find information on and for programmers like me who haven&#8217;t touched C since college, I thought it might be useful to try to document some of these concepts in a more understandable way here.</p>


	<h2>Packfiles</h2>


	<h3>What is a packfile and when are they created?</h3>


	<h3>Packfile format</h3>


	<h3>How does Git actually create a packfile?</h3>


	<h1>The Git Protocol</h1>


	<p>port 9418</p>


	<p>If it wants to invoke git-upload pack, it sends something like &#8216;0053upload-pack path/to/repo<NUL>host=git.server.example:9148&#8217;.</p>


	<p>Also, if server sends incomplete datastream back, you need to complete it before stroing. You also need to compute the index file for the pack.</p>


	<p>thanks to Ilari on <span class="caps">IRC</span></p>


	<p>http://www.kernel.org/pub/software/scm/git/docs/git-daemon.html</p>


	<h1>References and Endnotes</h1>


	<p>Here are some references that I used or that you may use to find out more about Git.</p>


	<p>The example git repository that I was working with throughout this book can be cloned from it&#8217;s 
<a href="http://github.com/schacon/simplegit">GitHub repository</a></p>


	<h2>Web Documentation</h2>


	<p><a href="http://www.kernel.org/pub/software/scm/git/docs/">Main Git Documentation</a>
- fantastic reference for all the command line programs</p>


	<p><a href="http://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a>
- good detail about the <span class="caps">DAG</span> object model</p>


	<p><a href="http://kerneltrap.org/node/5496">Junio Hamano New Git Maintainer</a>
- some history on git and Junio becoming the new maintainer</p>


	<p><a href="http://wincent.com/knowledge-base/Git_rebase_explained">Git Rebase Explained</a></p>


	<h2>Screencasts</h2>


	<p><a href="http://peepcode.com/products/git">Git Peepcode Screencast</a></p>


	<p><a href="http://railscasts.com/episodes/96">RailsCasts Git Screencast</a></p>


	<p><a href="http://www.jointheconversation.org/railsgit">Using Git to Manage and Deploy Rails Apps</a></p>
