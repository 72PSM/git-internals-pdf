h2. Git Object Types 

There are four main object types in git, the first three being the most important to really understand the main functions of git.

All of these types of objects are stored in the git object database, which is kept in the git directory [see git directory].  Each object is compressed (with Zlib) and referenced by the SHA1 value of its contents plus a small header.  In the examples, I will use the first 6 characters of the SHA for simplicity, but the actual value is 40 characters long.

To demonstrate these examples, we will develop a small ruby library that provides very simple bindings to git, keeping the project in a git repository.  The basic layout of the project is this:

!../artwork/s1/layout.png!

Let's take a look at what git does when this is committed to a repository.

h3. The Blob

_sidebar of git object sha algorithm (git-object-sidebar.textile)_

In git, the contents of files are stored as *blobs*.

!../artwork/s1/blobs.png!

It is important to note that it is the _contents_ that are stored, not the files.  The names and permissions of the files are not stored with the blob, just the contents.  

!../artwork/s1/blob-expand.png!

This means that if you have two files anywhere in your project that are exactly the same, even if they have different names, git will only store the blob once.  This also means that during repository transfers, such as clones or fetches, git will only transfer the blob once, then expand it out into multiple files upon checkout.

h3. The Tree

_sidebar of tree object encoding algorithm (git-tree-sidebar.textile)_

Directories in git basically correspond to *trees*.  

!../artwork/s1/trees.png!

A tree is a list of trees and blobs that the tree contains, along with the names and permissions of those blobs and trees.  The contents section of a tree object consists of a very simple text file that lists the _mode_, _type_, _name_ and _sha_ of each entry (see the sidebar for details).

!../artwork/s1/tree-expand.png!


h3. The Commit

So, now that we can store arbitrary trees of content in Git, where does the 'history' part of 'tree history storage system' come in?  The answer is the *commit* object.

!../artwork/s1/commit.png!

The commit is very simple, much like the tree.  It simply points to a tree and keeps an _author_, _committer_, _message_ and any _parent_ commits that directly preceded it.  

!../artwork/s1/commit-expand.png!

Since this was my first commit, there are no parents.  If I commit a second time, the commit object will look more like this:

!../artwork/s1/commit-expand2.png!

Notice how the _parent_ in that commit is the same SHA1 value of the last commit we did?  Most times a commit will only have a single parent like that, but if you merge two branches, the next commit will point to both of them.

note. the current record for number of commit parents in the Linux kernel is 12 - _12_ branches merged in a single commit 

h3. The Tag

The final type of object you will find in a git database is the *tag*.  This is an object that provides a permanent shorthand name for a particular commit.  It contains an _object_, _type_, _tag_, _tagger_ and a _message_. Normally the type is a 'commit' and the object is the sha of the commit you're tagging.  The tag can also be GPG signed, providing cryptographic integrity to a release or version.

!../artwork/s1/tag-expand.png!

We'll talk a little bit more about tags and how they differ from _branches_ (which also point to commits, but are not stored as objects) in the section on [the git data model], where we'll pull all of this together into how all these objects relate to each other conceptually.